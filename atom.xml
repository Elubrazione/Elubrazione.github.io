<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://elubrazione.github.io/atom.xml" rel="self"/>
  
  <link href="https://elubrazione.github.io/"/>
  <updated>2024-09-06T09:11:53.719Z</updated>
  <id>https://elubrazione.github.io/</id>
  
  <author>
    <name>Elubrazione</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>knob-tuning</title>
    <link href="https://elubrazione.github.io/2024/09/05/knob-tunning/"/>
    <id>https://elubrazione.github.io/2024/09/05/knob-tunning/</id>
    <published>2024-09-05T04:18:37.000Z</published>
    <updated>2024-09-06T09:11:53.719Z</updated>
    
    <content type="html"><![CDATA[<p>reading notes of a survey about knob tuning</p><span id="more"></span><h1 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h1><h2 id="tuning-problems"><a href="#tuning-problems" class="headerlink" title="tuning problems"></a>tuning problems</h2><ul><li><u>what are the tuning objectives</u><ul><li>performance evaluation<ul><li>configure the databases for <strong>high performance</strong> &#x3D;&gt; throughput, latency</li><li>improve <strong>resource utilization</strong> , thus reduce maintenance costs without sacrificing performance &#x3D;&gt; i&#x2F;o, memory usage</li></ul></li><li>a tuning methoad is evaluated from<ul><li>performance &#x3D;? how well it can achieves the objectives in a given scenario</li><li>Overhead &#x3D;&gt; how much time or system resource it requires</li><li>Adaptivity (<strong>more crucial for online tuning</strong>) &#x3D;&gt; how well it achieves the objectives in new scenarios</li><li>safety (<strong>more crucial for online tuning</strong>) &#x3D;&gt; whether it can avoid selecting knob settings that cause performance degradation</li></ul></li></ul></li><li><u>what to tune</u><ul><li>how to evaluate the knob-performance relations</li><li>how to select important knobs</li></ul></li><li><u>With what to tune</u> &#x3D;&gt; how to select tuning features (workloads, database state, hardware enviroments), which can reflect the database execution behaviors and potentially <strong>affect the tuning performance</strong><ul><li>tuning fatures are in high demensional space<ul><li>many features capture similar tuning characteristics <strong>&#x3D;&gt; drop the redundant features</strong></li></ul></li><li>many fatures are in deversified domains <strong>&#x3D;&gt; combine or embed useful features into the same input domain</strong></li></ul></li><li><u>how to tune</u><ul><li>the search space is large</li><li>obtaining the tuning performance is <strong>costly</strong></li><li>Not intelligently recommend knob setting based on <strong>scenario characteristic and tuning objectives</strong></li></ul></li></ul><p>![Screenshot 2024-09-05 at 12.35.34](.&#x2F;knob-tunning&#x2F;Screenshot 2024-09-05 at 12.35.34.png)</p><h1 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h1><p>knob tuning <strong>includes</strong></p><h2 id="knob-selection"><a href="#knob-selection" class="headerlink" title="knob selection"></a>knob selection</h2><h3 id="Main-categories-of-knobs"><a href="#Main-categories-of-knobs" class="headerlink" title="Main categories of knobs"></a>Main categories of knobs</h3><ul><li>access control<ul><li>affect the database performance by balancing the <strong>cocurrency and execution efficiency</strong></li><li>vital to select cocurrency knob to balance <strong>throuput and latency</strong></li></ul></li><li>query optimization<ul><li>controls the generation of query plans<ul><li>whether to use sequential scan or index scan</li></ul></li><li>affect the quality of generated query plans from <u>three</u> main aspects<ul><li>physical operators</li><li>planning policies</li><li>cost evaluation</li></ul></li><li>can generate efficient query plans that significantly improve the query performance.</li></ul></li><li>quey execution<ul><li>aim to configure physical execution mechanisms</li></ul></li><li>Background processes &#x3D;&gt; BP</li><li>resource management &#x3D;&gt; RM</li></ul><h3 id="Existing-selection-algorithm"><a href="#Existing-selection-algorithm" class="headerlink" title="Existing selection algorithm"></a>Existing selection algorithm</h3><p>&#x3D;&gt; <strong>filter</strong> unimportant knobs and <strong>reduce</strong> the configuration space</p><ul><li>Empirical-based</li><li>Ranking-based</li><li><u>pros of above two</u><ul><li>rely on simple assumptions</li><li>can’t capture the correlations of knobs</li><li>miss valuable knobs</li><li>rely on a large numer of samples</li></ul></li></ul><h2 id="Feature-selection"><a href="#Feature-selection" class="headerlink" title="Feature selection"></a>Feature selection</h2><h3 id="commonly-used-features"><a href="#commonly-used-features" class="headerlink" title="commonly-used features"></a>commonly-used features</h3><ul><li>workload features<ul><li>operators, execution costs</li></ul></li><li>database metric features<ul><li>extracted from executions</li><li>can infer the database state under the workload</li></ul></li></ul><h3 id="existing-techniques"><a href="#existing-techniques" class="headerlink" title="existing techniques"></a>existing techniques</h3><h2 id="Tuning-methods"><a href="#Tuning-methods" class="headerlink" title="Tuning methods"></a>Tuning methods</h2><h3 id="4-tuning-methods"><a href="#4-tuning-methods" class="headerlink" title="4 tuning methods"></a>4 tuning methods</h3><ul><li>heuristic<ul><li>cons &#x3D;&gt; easy to implement</li><li>pros<ul><li>randomly sample, challenging to find promising settings among large configuration space within limited tuning time</li><li>can not use historical tuning data and prior knowledge</li><li>waste time in evaluating the search space of inferior settings</li></ul></li></ul></li><li>bo-based<ul><li>cons<ul><li>can <strong>quickly find high-quality knob settings when the knob number is small</strong></li><li>do not require prepared training data</li></ul></li><li>pros &#x3D;&gt; <strong>cannot efficiently represent and explore large configuration space</strong> since it base on probability distribution assuming thhe knob-performance relations following gaussian distribution</li></ul></li><li>Deep learning &#x3D;&gt; replace the gaussian process model with neural networks<ul><li>pros &#x3D;&gt; require a large number of high-quality samples to train</li></ul></li><li>reinforcement learning &#x3D;&gt; proposed to explore suitable settings by the inteaction between the agent (the tuning model) and the environment (the taeget database)<ul><li>Cons<ul><li>do not require prepared training data</li><li>have no limitation on the size of the configuration space</li></ul></li><li>pros<ul><li>the overhead is much higher than bo-based method</li><li>performance greatly depends on the initially sampled knob settings</li></ul></li></ul></li></ul><h3 id="challenges-summary"><a href="#challenges-summary" class="headerlink" title="challenges summary"></a>challenges summary</h3><p>&#x3D;&gt; How existing methods address those challenges</p><h2 id="transfer-techniques"><a href="#transfer-techniques" class="headerlink" title="transfer techniques"></a>transfer techniques</h2><p>&#x3D;&gt; utilize historically well-trained tuning models</p><h3 id="common-feature-extraction"><a href="#common-feature-extraction" class="headerlink" title="common feature extraction"></a>common feature extraction</h3><ul><li><p>directly extracts the <strong>common</strong> features of <strong>different</strong> workloads</p></li><li><p>two main challenges</p><ul><li><p>workload may have different access patterns, hard to embed for unseen workloads</p></li><li><p>need to design an extra workload embedding model, which require much prepared training data</p></li></ul></li></ul><h3 id="adaptive-weight-transferring"><a href="#adaptive-weight-transferring" class="headerlink" title="adaptive weight transferring"></a>adaptive weight transferring</h3><ul><li>adapt to new scenarios by preparing a suite of tuning models that are welltrained under historical workloads<ul><li>use similarity to map new workload to an old one</li></ul></li></ul><h2 id="knob-tuning-system"><a href="#knob-tuning-system" class="headerlink" title="knob tuning system"></a>knob tuning system</h2><ul><li>Commercial relational database</li><li>big data analytics systems</li></ul><p>research challenges and future opportunities</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;reading notes of a survey about knob tuning&lt;/p&gt;</summary>
    
    
    
    <category term="database" scheme="https://elubrazione.github.io/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>automl-paper-survey</title>
    <link href="https://elubrazione.github.io/2024/06/20/automl-paper-survey/"/>
    <id>https://elubrazione.github.io/2024/06/20/automl-paper-survey/</id>
    <published>2024-06-20T09:12:40.000Z</published>
    <updated>2024-09-07T03:47:52.332Z</updated>
    
    <content type="html"><![CDATA[<p>。</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="machine-learning"><a href="#machine-learning" class="headerlink" title="machine learning"></a>machine learning</h2><ul><li>the <strong>learning algorithm</strong> outputs a model whereas <strong>the model</strong> outputs predictions<ul><li>the learning algorithm  take in pre-processed data and output a model</li><li>then the model is different in the sense that it takes in new inputs or just inputs and its outputs are predictions for those inputs</li></ul></li><li>difference between <strong>parameter</strong> and <strong>hyperparameter</strong><ul><li>the <strong>model</strong> is often associated with <strong>parameters</strong> denoted by the symbol and parameters <strong>control the behavior of the model</strong> which is <strong>determined by the learning algorithm</strong>, so the learning algorithm often outputs these parameters and we do not have to think about them ourselves as human experts</li><li>the <strong>learning algorithm also has parameters</strong> but to distinguish these from the model parameters we call them <strong>hyperparameters</strong>. It <strong>control the learning outward</strong> and these are often <strong>determined by the humans</strong>. </li><li>example:<ul><li><strong>parameters</strong>: the thresholds in every node and maybe the rows that we use to go either left or right (for a neural network and in a decision tree)</li><li><strong>hyperparameter</strong>: something like the learning rate, the momentum value and so on (when trained with gradient descent)</li></ul></li></ul></li></ul><h2 id="role-of-the-human-experts"><a href="#role-of-the-human-experts" class="headerlink" title="role of the human experts"></a>role of the human experts</h2><ul><li>what <strong>data processing</strong> steps: cleaning, feature engineering like what feature extraction and deed into the learning algorithm etc</li><li>what <strong>learning algorithm</strong> do we use, svm, logistic regression, neural network</li><li>what hyperparameters do we use for the given learning algorithm (<strong>hyperparameters selection</strong>)</li></ul><p><strong>automated machine learning &#x3D; automating one or more of these things</strong></p><h2 id="ml-x3D-gt-automl"><a href="#ml-x3D-gt-automl" class="headerlink" title="ml &#x3D;&gt; automl"></a>ml &#x3D;&gt; automl</h2><p>when determine data processing, learning algorithm and hyperparameters:</p><p>we introduce <strong>an automl agent</strong> which is either responsible for part of the choices that have to be made or it can fully replace the human and be responsible for making all of these choices.</p><p><img src="/2024/06/20/automl-paper-survey/image-20240826125411325.png" alt="image-20240826125411325"></p><h2 id="why-automate-ml"><a href="#why-automate-ml" class="headerlink" title="why automate ml"></a>why automate ml</h2><p>choice of preprocessing, learning algorithm and hyperparameters is <strong>crucial</strong> for achieving  good performance</p><ul><li>finding good setting for these components <strong>requires expert domain knowledge</strong> so this is something often done by data scientists who understand the machine learning algorithm and understand the influence of the different choices on the performance</li><li><strong>takes a lot of tedious effort and is expensive</strong> to actually find correct settings for all of these components in order to be satisfied with the performance</li><li>having a human finding good settings for these components maybe <strong>suboptimal</strong></li></ul><p>use automl we can </p><ul><li><p>no longer need expert domain knowledge</p></li><li><p><strong>increase the wide applicability and lower the threshold for actually using these techniques</strong> </p></li><li><p>better performance</p></li></ul><h2 id="auto-ml"><a href="#auto-ml" class="headerlink" title="auto ml"></a>auto ml</h2><p>consists of 3 parts:</p><ul><li><strong>search space</strong>: all of the different hyperparameters values maybe pre-processing steps etc over which the agent can search</li><li><strong>search algorithm</strong>: determines how it is going to search through this search spase </li><li><strong>evaluation mechanism</strong>: what we do in search i s we want to try to maximize the performance, so we need to have some kinds of evaluation mechanism <ul><li>that allows us to <strong>distinguish candidate solutions</strong> in the search space from each other </li><li>and which allows us to <strong>guide the search</strong> towards more and more promising or well-performing methods</li></ul></li></ul><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>overview$^{[1]}$, we only care about the part of neural architecture search (NAS) </p><p><img src="/2024/06/20/automl-paper-survey/image-20240627163937730.png" alt="image-20240627163937730"></p><ul><li>search space</li><li>architecture optimization<ul><li>evolutionary algorithm</li><li>reinforcement learning</li><li>gradient descent</li><li>bandit-based<ul><li>successive halving</li><li>hyperba</li></ul></li><li><strong>surrogate model-based optimization</strong><ul><li>EGO&#x2F;TB-SPO</li><li><strong>bayesian optimization (BO)</strong><ul><li>Gaussian process (GP)</li><li>random forest (RF)</li><li>tree-structured parzen estimator (TPE)</li><li>bo-based hyperband (BOHB), combines the strengths of TPE-based BO and hyperband</li></ul></li><li>neural networks</li></ul></li></ul></li></ul><h1 id="CASH-vs-HPO"><a href="#CASH-vs-HPO" class="headerlink" title="CASH vs HPO"></a>CASH vs HPO</h1><h2 id="definition-of-CASH"><a href="#definition-of-CASH" class="headerlink" title="definition of CASH"></a>definition of CASH</h2><p>CASH &#x3D; combined algorithm selection and hyperparameter optimization</p><p>given:</p><ul><li>$\mathcal{T}$: task we want to solve</li><li>$\mathcal{D}_{train}$: the training data</li><li>$\mathcal{L_T}$: the loss function &#x3D;&gt; performance metric which measures how poorly our solutions are performing</li><li>(we want to find the best algorithm and the best hyperparameters)<ul><li>$\mathcal{A}$: the space of all algorithms over which we search</li><li>$\Theta$: the space of hyperparameters over which we search</li></ul></li></ul><p>we want to find:</p><p>$$A^*, \theta^* &#x3D; \arg\min\limits_{A \in \mathcal{A}, \theta \in \Theta} \space \mathbb{E}<em>\mathcal{pT} [\mathcal{L_T}(A_\theta(D</em>{train}))]$$</p><p>where</p><ul><li><p>hyperparameter vector $\theta &#x3D; [\theta_1 \theta_2 \dots \theta_n]$</p><ul><li>e.g. , [learning rate, momentum, use_batch_norm]</li></ul></li><li><p>$A_\theta(D_{train})$ means the <strong>output of learning algorithm</strong>, namely the <strong>model</strong> (the algorithm takes in the data and outputs a model)</p></li><li><p>$\mathcal{L_T}(A_\theta(D_{train}))$​ means the <strong>loss of the model</strong> on a given data point </p></li><li><p>$\mathbb{E}_\mathcal{pT}$​ means <strong>the expected or mean loss</strong> of the model</p></li></ul><p>in short, we want to find the <strong>best of algorithm and hyperparameter</strong> such that we minimize…</p><h2 id="definition-of-HPO"><a href="#definition-of-HPO" class="headerlink" title="definition of HPO"></a>definition of HPO</h2><p>based on definition of CASH, assume that the algorithm is given so we no longer want to find a best algorithm</p><p><strong>given</strong> a certain learning algorithm, we only want to <strong>find</strong> the best hyperparameters:</p><p>$$\theta^* &#x3D; \arg\min\limits_{\theta \in \Theta} \space \mathbb{E}<em>\mathcal{pT} [\mathcal{L_T}(A_\theta(D</em>{train}))]$$</p><h2 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a>relationship</h2><p>HPO &#x3D; CASH when <strong>including the algorithm as “hyperparameters”</strong></p><p>&#x3D;&gt; <u>将【算法】作为超参数包含在我们的结果$\theta$中</u></p><h1 id="GS-vs-RS"><a href="#GS-vs-RS" class="headerlink" title="GS vs RS"></a>GS vs RS</h1><h2 id="grid-search"><a href="#grid-search" class="headerlink" title="grid search"></a>grid search</h2><h3 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h3><ul><li>define sets of values you want to try for some (or all)  hyperparameters, evaluate <strong>all possible combinations</strong> &#x3D;&gt; traversal</li></ul><p><strong>value sets</strong>:</p><p>$v(\theta_1) &#x3D; { 0.1, 0.01, 0.001 }$</p><p>$v(\theta_2) &#x3D; { 0.99, 9.9,  0.8 }$</p><p>$\dots$</p><p>$v(\theta_n) &#x3D; { True, False }$</p><p><strong>evaluate</strong>:</p><p>$v(\theta_1) \times v(\theta_2) \times \dots \times v(\theta_n)$</p><p>this evaluation procedure is often done on a validation set, not training set because that will give us a biased view and may lead to over-fitting</p><h3 id="pros-and-cons"><a href="#pros-and-cons" class="headerlink" title="pros and cons"></a>pros and cons</h3><ul><li>pro<ul><li>simple</li><li>easy to parallelize</li></ul></li><li>cons<ul><li><strong>waste</strong> of compute when one or more hpms are not important</li><li><strong>scalability</strong> (exponential growth number of combinations)</li><li>how to define the grid: how do we know that <strong>the values that we put in the value sets are actually good values to try out</strong><ul><li>this is what <strong>random search</strong> actually kind of solves</li></ul></li></ul></li></ul><h2 id="random-search"><a href="#random-search" class="headerlink" title="random search"></a>random search</h2><h3 id="definition-1"><a href="#definition-1" class="headerlink" title="definition"></a>definition</h3><ul><li><p>define <strong>probability distribution</strong>s on <strong>ranges</strong> of values for every hyperparameters, draw hyperparameters configurations and evaluate</p></li><li><p><strong>sample from the range and sample according to some kind of probability distribution that we have defined over this range</strong></p></li></ul><p><strong>distributions</strong>:</p><p>$p(\theta_1) &#x3D; LogUniform(0.001, 0.1)$ &#x3D;&gt; we transform both of these two values (minimum and maximum) into log space, we sample in the log space and then we transform the sampled values back to the original space</p><p>$p(\theta_2) &#x3D; Uniform(0.8, 0.99)$</p><p>$\dots$</p><p>$p(\theta_n) &#x3D; Categorical({ True, False })$</p><p> <strong>evaluate M configurations</strong>:</p><p>$\theta \sim p(\theta_1, \theta_2, \dots, \theta_n)$</p><p>we evaluate samples from <strong>the joint distribution</strong></p><p>in order to <strong>sample one configuration</strong>, we have to sample the first value from the first distribution, the second value from the second distribution etc</p><p>so we need to sample <strong>in total from M times</strong> in n distributions</p><h3 id="pros-and-cons-1"><a href="#pros-and-cons-1" class="headerlink" title="pros and cons"></a>pros and cons</h3><ul><li>pros<ul><li>simple</li><li>easy to parallelize</li><li>can set a budget of function evaluations (evaluate M hyperparameter configurations)</li><li>theoretical guarantees of convergence with proper ranges<ul><li>not really has any meaning in practical scenarios</li></ul></li></ul></li><li>cons<ul><li>not data efficient</li><li>still expensive</li></ul></li></ul><h2 id="relationship-1"><a href="#relationship-1" class="headerlink" title="relationship"></a>relationship</h2><p><img src="/2024/06/20/automl-paper-survey/image-20240826151400164.png" alt="image-20240826151400164"></p><p>random search is more efficient when there are unimportant hyperparameters (better coverage)</p><h1 id="Successive-Halving-vs-Hyperband"><a href="#Successive-Halving-vs-Hyperband" class="headerlink" title="Successive Halving vs Hyperband"></a>Successive Halving vs Hyperband</h1><p>downside of gs and rs: every hyperparameters configuration is <strong>fully trained</strong> &#x3D;&gt; expensive</p><p>we can detect early on that a configuration will be bad and discard it, so techniques to do this:</p><ul><li>successive halving</li><li>hyperband &#x3D;&gt; the extension of successive halving</li></ul><h2 id="successive-halving"><a href="#successive-halving" class="headerlink" title="successive halving"></a>successive halving</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>on the <strong>x-axis</strong> we have compute budget which can think of as the total number of epochs</p><p>on the <strong>y-axis</strong> we have the performance metric, here is loss</p><p><img src="/2024/06/20/automl-paper-survey/image-20240826155923846.png" alt="image-20240826155923846"></p><p>in round 0 we start a randomly sampled configuration.</p><p>(after making a number of training steps we evaluate all configurations in this round) &#x3D;&gt; <strong>throw the worst half off and continue training the best half</strong></p><ul><li>we simply throw away the worst half of these configurations</li><li>we stop training them and we continue training the best half</li></ul><p><img src="/2024/06/20/automl-paper-survey/image-20240826160706655.png" alt="image-20240826160706655"></p><h3 id="definition-2"><a href="#definition-2" class="headerlink" title="definition"></a>definition</h3><ul><li><p>start a set of $n$ random initial configurations ${ A_\theta^{(i)} }^n_{i&#x3D;1}$ and a budget $B$</p></li><li><p>every round the candidate pool size is divided by $\gamma$​ which means halving rate</p></li><li><p>we only perform $log_\gamma(n)$​ rounds</p></li><li><p>budget is <strong>divided uniformly rounds</strong></p><ul><li>but because we throw away configurations in every round  what this basically means is that <strong>every configuration is assigned more budget per round</strong> </li><li>consequently we <strong>assign exponentially more budget to good configurations</strong></li></ul></li><li><p>example</p><ul><li>number of initial configurations n &#x3D; 64. total budget B &#x3D; 384, halving rate $\gamma$ &#x3D; 2 </li><li>computation metric<ul><li>round &#x3D;&gt; k</li><li>number of candidate pool in this round &#x3D;&gt; $S_k$</li><li>budget in this round per configuration &#x3D;&gt; $r_k$​</li></ul></li><li>procedure<ul><li>$log_2(64) &#x3D; 6$, so we only need to perform 6 rounds, namely k &#x3D; { 0, 1, 2, 3, 4, 5 }</li><li>$\gamma &#x3D; 2$, so $S_k$​ &#x3D; { 64, 32, 16, 8, 4, 2 }</li><li>since budget is divided uniformly rounds, we have 6 rounds here, the budget of each round is 384&#x2F;6 &#x3D; 64. then we divide the total budget per round by $S_k$, namely 64&#x2F;$S_k$, so $r_k$ &#x3D; {1, 2, 4, 8, 16, 32 }</li></ul></li></ul></li></ul><h3 id="hyperparameters"><a href="#hyperparameters" class="headerlink" title="hyperparameters"></a>hyperparameters</h3><ul><li><p>higher budget &#x3D;&gt; higher budget per configuration (<strong>more informed decisions and more compute time</strong>s)</p></li><li><p>higher halving rate &#x3D;&gt; more aggressive pruning (could be too aggressive and <strong>disregard the best candidate early o</strong>n, imagine a configuration which starts learning quite slow and only after a certain number of epochs starts to really maximize the performance)</p></li></ul><h3 id="pros-and-cons-2"><a href="#pros-and-cons-2" class="headerlink" title="pros and cons"></a>pros and cons</h3><ul><li><p>pros</p><ul><li>allow us to work with fixed budget</li><li>good experical results</li><li>strong theoretical foundations</li><li>parallelizable</li></ul></li><li><p>cons</p><ul><li><p>learning curves can cross (good candidates to be discarded early)</p></li><li><p>n &#x2F; B trade-off, given a fixed budget B </p><p><img src="/2024/06/20/automl-paper-survey/image-20240826170638588.png" alt="image-20240826170638588"></p><ul><li>larger n &#x3D;&gt; smaller amount of time per config</li><li>smaller n &#x3D;&gt; larger amount of time per config</li><li>we do not know which works best &#x3D;&gt; <strong>this is what hyperband actually solves</strong></li></ul></li></ul></li></ul><h2 id="hyperband"><a href="#hyperband" class="headerlink" title="hyperband"></a>hyperband</h2><h3 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h3><p>running successive halving <strong>different times with different values of n</strong></p><ul><li>firstly, it does <strong>a bracket of successive halving</strong>  using a large number of initial configurations </li><li>then it simply randomly sample <strong>another set of initial configurations</strong> and this time <strong>lower the amount</strong> than in our previous round </li><li>we again decrease the candidate pool size until we are in our final bracket which is equivalent to a random search</li></ul><h3 id="definition-3"><a href="#definition-3" class="headerlink" title="definition"></a>definition</h3><p>perform different successive halving with hyperband (here we call bracket) $s_{max} + 1$ times with various initial candidate pool size $n$ (in essence performing a grid search over feasible value of $n$) for a fixed budget $B$</p><ul><li><strong>start with large $n$</strong> (we do quite some exploration, but less time per configuration), subject to the constraint that <strong>at least one configuration is allocated R resources.</strong> </li><li>every consecutive bracket, <strong>reduce n</strong> (we decrease the n which means that we will get more time per configuration but a smaller number of configurations and this also leads to less exploration) <strong>until the final bracket</strong>, s &#x3D; 0, in which <strong>every configuration is allocated R resources</strong> (this bracket simply performs classical <strong>random search</strong>)</li></ul><p>conclusion &#x3D;&gt; there are two components to hyperband</p><ul><li><strong>the inner loop</strong> invokes successive halving for fixed values of n and r</li><li><strong>the outer loop</strong> iterates over different values of n and r</li></ul><h3 id="hyperparameters-1"><a href="#hyperparameters-1" class="headerlink" title="hyperparameters"></a>hyperparameters</h3><ul><li><p>R: maximum resource that can be allocated to a single configuration within a round of successive halving</p></li><li><p>$\gamma$: control proportion or discarded configurations every round</p></li><li><p>example</p><ul><li>various brackets, with R &#x3D; 81 and $\gamma &#x3D; 3$​</li><li>firstly, we consider the number of different brackets we need to perform, it’s $s_{max} + 1 &#x3D; log_{\gamma}(R) + 1 &#x3D; log_3(81) + 1 &#x3D; 4 + 1 &#x3D; 5$. and  $B &#x3D; (s_{max} + 1) R &#x3D; 5R$</li><li><strong>In the $s_{max}$ bracket</strong>: since we have a fixed budget R &#x3D; 81, according to the algorithm, we start with a large number of configurations n, so here n is equivalent to R, namely 81 (or we can compute according to the equation $n &#x3D; \gamma^{s_{max}} &#x3D; 3^4 &#x3D; 81$). so in the round zero, budget for each configuration $r_i$ is R&#x2F;n &#x3D; 81&#x2F;81 &#x3D; 1. then in the next round of this bracket we perform the algorithm as successive halving until the budget for each configuration in the round is equal to R</li><li><strong>then in the third bracket</strong>, we decrease the initial number of configurations using given halving rate $\gamma &#x3D; 3$, so <strong>n of  round zero of second bracket</strong> should be $81 &#x2F; 3 &#x3D; 27$ (<strong>we can compute according to the equation $n &#x3D; \lceil  \frac{5R}{R} \frac{\gamma^s}{s+1} \rceil &#x3D; \lceil 5 \frac{3^3}{3+1} \rceil &#x3D; 34$, so we chose 27 because 27 &lt; 34 and the output of $log_3(27)$ is an integer</strong>). note that we have fixed maximum budget for all configurations in each round, still be R &#x3D; 81, so this time the budget for each configuration $r_0 &#x3D; R&#x2F;n_0 &#x3D; 81&#x2F;27 &#x3D; 3$</li><li><strong>in the second bracket</strong>, we perform as before. the initial value of $n_i$ and $r_i$ should be 27&#x2F;3&#x3D;9 and 81&#x2F;9&#x3D;9 ($n &#x3D; \lceil  \frac{5R}{R} \frac{\gamma^s}{s+1} \rceil &#x3D; \lceil 5 \frac{3^2}{2+1} \rceil &#x3D; 15$, so we chose 9)</li></ul><p><img src="/2024/06/20/automl-paper-survey/image-20240826223328862.png" alt="image-20240826223328862"></p><p><img src="/2024/06/20/automl-paper-survey/image-20240826203654749.png" alt="image-20240826203654749"></p></li></ul><h1 id="SMBO"><a href="#SMBO" class="headerlink" title="SMBO"></a>SMBO</h1><p>surrogate model-based optimization</p><h2 id="limitation-of-techinique-so-far"><a href="#limitation-of-techinique-so-far" class="headerlink" title="limitation of techinique so far"></a>limitation of techinique so far</h2><ul><li>they <strong>randomly select initial candidates</strong> to evaluate</li><li>but if we have already evaluated a set of candidates, we can do better than random selection<ul><li>predict promising regions <strong>based on history of observations</strong></li><li>we could <strong>fit a model to our previous observations</strong> and then use this model to predict the most promising regions or <strong>the most promising hyperparameter configurations</strong></li></ul></li></ul><h2 id="idea-2"><a href="#idea-2" class="headerlink" title="idea"></a>idea</h2><ul><li><p>learn a <strong>surrogate model</strong> that for every configuration $\theta \in \Theta$:</p><ul><li><p>predicts the loss or <strong>performance</strong></p></li><li><p>provides a measure of <strong>uncertainty</strong> about the prediction</p></li></ul></li><li><p>loosely speaking, the surrogate models $P(y \vert \theta)$, where y denotes the performance and $\theta$​ denotes a given hyperparameter</p></li><li><p>so we need to <strong>update the surrogate model sequentially</strong> as new observations (tried configuration, performance) arrive</p></li><li><p>and we use the surrogate model to <strong>select new promising configurations to evaluate</strong></p></li></ul><p><img src="/2024/06/20/automl-paper-survey/image-20240627164911129.png" alt="image-20240627164911129"></p><ul><li>symbol explanations<ul><li>evaluation function &#x3D;&gt; $f$</li><li>search space &#x3D;&gt; $\Theta$</li><li>acquisition function &#x3D;&gt; $S$</li><li>probability model &#x3D;&gt; $M$</li><li>dataset $D$, it includes many sets of samples $(θ_i, y_i)$ where $\theta_i \in \Theta$ and $y_i$ denotes the performance of $\theta_i$​</li></ul></li></ul><h2 id="instantiation"><a href="#instantiation" class="headerlink" title="instantiation"></a>instantiation</h2><ul><li>bayesian optimization<ul><li>start with a prior distribution, namely start with initial surrogate model and as data points come in and as we try out more configuration and observe their performances</li><li>we repeat: update our beliefs about the loss surface so that we update our surrogate model</li></ul></li></ul><h2 id="surrogate-model"><a href="#surrogate-model" class="headerlink" title="surrogate model"></a>surrogate model</h2><ul><li><p>Gaussian process (good <strong>confidence bounds</strong>, however only <strong>numerical</strong> hyperparameters)</p><ul><li>face some <strong>challenge</strong> when having <strong>categorical</strong> hyperparameter, it’s not easy to incorporate it</li></ul></li><li><p><strong>random forest</strong> (categorical and conditional hyperparameters)</p><ul><li><strong>categorical</strong> &#x3D;&gt; a boolean flag where we want to use batch normalization in a neural network</li><li><strong>conditional</strong> &#x3D;&gt; hyperparameters that are only defined if some other hyperparameter is satisfied with some constraints. suppose we have a neural network and we have one hyperparameter that is the number of nodes in layer number 3, now for this hyperparameter to actually carry any meaning we need to have the other hyperparameter value which is the number of layers to be larger or equal than 3 because otherwise this one hyperparameter does not make any sense.</li></ul></li></ul><h1 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h1><blockquote><p>referencing the blog post$^{[2]}$, this part add some understanding and other supplementary content related to mathematics</p></blockquote><h2 id="似然估计与其函数"><a href="#似然估计与其函数" class="headerlink" title="似然估计与其函数"></a>似然估计与其函数</h2><p>回顾总结一下遗忘的知识：</p><ol><li>先验概率：在结果发生前就获得的、根据历史规律确定原因的概率，即 $p(因) &#x3D; p(x)$；</li><li>后验概率：已知结果，猜测原因，即 $p(因 \vert 果) &#x3D; p(x \vert y)$</li><li>似然估计：已知原因，猜测原因对应的结果的概率，即 $p(果\vert 因) &#x3D; p(y \vert x)$​</li></ol><p><strong>联合概率密度函数</strong>：$p(x, y) &#x3D; p(x \vert y)p(y) &#x3D; p(y \vert x)p(x)$</p><p><strong>贝叶斯公式</strong>：$p(x \vert y) &#x3D; \frac{p(y \vert x)p(x)}{p(y)} &#x3D; \frac{p(y \vert x)p(x)}{\int p(y \vert x)p(x) dx}$​，根据似然概率和先验概率求后验概率。</p><p>而似然函数是用于描述观测数据与某个概率模型之间的关系的函数。假设有个概率模型，由一组未知参数 $\theta$ 描述，有一组观测数据 $D_0$，那么似然函数 $L(\theta | D_0)$ 就表示在给定数据 $D_0$ （因）下，参数 $\theta$ （果）取某个值的概率。</p><p>$$L(\theta|D_0) &#x3D; P(D &#x3D; D_0|\theta)$$</p><p>$P(D&#x3D;D_0|θ)$ 表示在参数 $θ$ （果）的条件下，数据 $D_0$ （因）出现的概率，后验概率。</p><p>通过最大化似然函数，我们可以找到参数 $θ$ 的最优估计值，也即使观测数据出现概率最大的参数值。</p><h2 id="problem-description"><a href="#problem-description" class="headerlink" title="problem description"></a>problem description</h2><p>$x^{*} &#x3D; arg\space \max\limits _{x \in \mathcal{X}} f(x)$</p><ul><li>这里 $\mathcal{X}$ 是超参数空间，比如对于一个随机森林模型，这里 $\mathcal{X}$ 就是模型和模型对应的参数，即 {  random_forest, n_ estimators, max_depth }。</li><li>$f(x)$ 是参数空间到我们感兴趣的一个指标的映射函数，如回归问题中的MSE或者分类问题中的accuracy和AUC指标。注意不是数据集到预测结果的映射，而是**在某个数据集下，某个模型及其相关的参数$\mathcal{X}$到我们关心的指标的映射 **，如 $f(x): \mathcal{X} \rightarrow acc$。</li><li>可以认为$f(x)$是一个黑盒函数，其计算代价很高，解决该优化问题被称为黑箱优化。</li><li>注意$f(x)$的凹凸性质，没有一阶或高阶导数，不能通过梯度下降或者牛顿相关算法进行求解，但我们知道$f(x)$是<strong>连续函数</strong>，因此可以使用<strong>高斯回归过程对$f(x)$进行建模</strong>。</li></ul><h2 id="iterating-method"><a href="#iterating-method" class="headerlink" title="iterating method"></a>iterating method</h2><p>对于 $y&#x3D;f(x)$，假设有个先验概率，每次有新的数据 ${ x_{data}, f(x_{data}) }$，求出y的后验概率 $p(y | (x_{data}, f(x_{data})))$，并把这个后验概率作为下一条数据的先验概率，如此迭代更新。</p><p><strong>重点是</strong>我们需要一个规则来找到基于当前情况的下一个迭代数据 $x_{next}$。所以我们需要基于当前 $y$ 的后验概率，定义一个acquisition function： $a_n(x | data)$，$x \rightarrow R$，这个函数用于计算在当前情况下不同的数据 $x$ 对 $y$ 的作用，从而去选择新的下一条数据 $x_{next}$ 以最大化 $a_n$。</p><h2 id="algorithm-procedure"><a href="#algorithm-procedure" class="headerlink" title="algorithm procedure"></a>algorithm procedure</h2><ol><li>给定一个 $y&#x3D;f(x)$ 的先验概率 $p_0$，最大迭代次数 $N$</li><li>随机初始化 $n_0$ 个点，并得到 $n_0$ 个点结果，即 ${ (x_1, f(x_1)), (x_2, f(x_2), …, (x_{n_0}, f(x_{n_0}))) }$</li><li>利用初始化的$n_0$个点，更新先验概率，并更新 $n \leftarrow n_0$</li><li>当 $n \leq N$ 时：<ul><li>根据当前的后验概率 $p(y | { (x_1, f(x_1)), (x_2, f(x_2), …, (x_{n_0}, f(x_{n_0}))) })$ 来计算 $a_n (x)$</li><li>选择能够最大化 $a_n(x)$ 的点作为 $x_{n+1}$。<strong>注：这一步是重点，该如何找到下一个迭代点 $x_{next}$ 以及过程中如何对 $p(y \vert x)$ 和 $p(y|x_{next})$ 进行建模</strong></li><li>将新的点 $x_{n+1}$ 带入得到 $f(x_{n+1})$ ，会非常耗时</li><li>$x \leftarrow n + 1$</li></ul></li><li>返回评估过的数据中使得 $f(x)$ 最大的点 $x^{*}$​</li></ol><h1 id="GP"><a href="#GP" class="headerlink" title="GP"></a>GP</h1><p>Gaussian Process Regression</p><p>主要解决前面提到的贝叶斯推断中的两个重点问题：1）概率建模；2）下一个迭代数据点的确认。</p><h2 id="probability-modeling"><a href="#probability-modeling" class="headerlink" title="probability modeling"></a>probability modeling</h2><h3 id="多维正态分布的似然函数"><a href="#多维正态分布的似然函数" class="headerlink" title="多维正态分布的似然函数"></a>多维正态分布的似然函数</h3><p>对于贝叶斯优化的初始化数据 ${ (x_1, f(x_1)), (x_2, f(x_2), …, (x_{n_0}, f(x_{n_0}))) }$，假设多维似然函数 $L$ 服从多维正态分布，后验概率密度为：</p><p>$p(y) &#x3D; \left( \begin{matrix} y_1 \ y_2 \ … \ y_{n_0} \end{matrix} \right) \sim N\left( \left(\begin{matrix} u_0(x_1) \ u_0(x_2) \ … \ u_0(x_{n_0}) \end{matrix}\right), \Sigma_{n_0 * n_0}\right)$</p><p>$\Sigma_{n_0 * n_0} &#x3D; \left [ \begin{matrix} k_{11}&amp;\dots&amp;k_{1 n_0} \ \vdots &amp; \ddots &amp; \vdots \ k_{n_01} &amp; \dots  &amp; k_{n_0n_0} \end{matrix} \right]$</p><p>注意这里 $\Sigma$ 是大写的 $\sigma$，一般来说 $\Sigma$ 是一个 $n_0 \times n_0$ 的协方差矩阵，这个矩阵描述了 $n_0$ 个数据两两之间的相关性。其计算方法：</p><ul><li>对角线元素 $\Sigma_{ii} &#x3D; Cov(x_i, x_i) &#x3D; K(x_i, x_i)$；</li><li>非对角线元素 $\Sigma_{ij} &#x3D; Cov(x_i, x_j) &#x3D; K(x_i, x_j)$</li></ul><p>这里对协方差矩阵的建模采用了核函数  $K(·,·)$，不同的核函数又会有不同的计算公式，如：</p><ul><li>线性核函数：$K(x_i, x_j) &#x3D; x_i^T x_j$，对两个向量做内积</li><li>高斯核函数：$K(x_i, x_j) &#x3D; e^{-\frac{||xi - xj||^2}{2σ^2}}$。<ul><li>$\sigma$ 是核函数的带宽参数，控制着核函数的平滑程度，$\sigma$ 越小，相关性变化越剧烈。</li><li>公式反映了不同变量 $x_i$ 和 $x_j$ 之间的相关性，距离才用了 $L2$ 距离，距离越近（$||x_i - x_j||^2$ 越小），相关性越强（$\Sigma_{ij}$ 越大），由公式得对角线元素为1。</li><li>该核函数满足了对称性且保证了协方差矩阵为非负正定矩阵（是一个对称矩阵，并且对于其中任意非零向量 $x$，$x$​ 与该矩阵的乘积都会得到一个正值）。</li><li>有时会让指数乘上一个其它的参数。</li></ul></li></ul><p><strong>（重要）</strong>为什么可以用 $x_i$ 和 $x_j$ 来反映 $y_i$ 和 $y_j$ 的关系？因为上面说过 $f(x)$ 是连续的！ </p><p>而均值向量中的 $u_0$ 是先验信息，即对于一个 $x$​ 先验的均值，在一开始就确定（一般设置为0）。</p><p>如此就根据已有数据确定了一个高斯过程。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>新加入的数据与之前数据继续构成多维正态分布，这一步需要得到当前数据点下 $p(y | x)$ 的分布，假设新的数据点为 $(x^*, f(x^*))$，且根据联合高斯概率密度函数：</p><p>$p(y, y_*) &#x3D; N\left( \left( \begin{matrix} \mu_y \ \mu_{y_*} \end{matrix} \right), \left( \begin{matrix} K &amp; K_* \ K_*^T &amp; k_{**}  \end{matrix} \right) \right)$</p><p>带入展开则得到新的数据点与之前的数据点一起构成新表达式：</p><p>$p(y, y_*) &#x3D; \left( \begin{matrix} y_1 \ y_2 \ … \ y_{n_0} \ y_* \end{matrix} \right) \sim N \left( \left(\begin{matrix} u_0(x_1) \ u_0(x_2) \ … \ u_0(x_{n_0}) \ u_0(x*) \end{matrix}\right), \Sigma_{(n_0 + 1) * (n_0 + 1)} \right) \ \Sigma_{(n_0 + 1) * (n_0 + 1)} &#x3D; \left [ \begin{matrix} k_{11} &amp; \dots &amp; k_{1{n_0}} &amp; k_{1*} \ \vdots &amp; \ddots &amp; \vdots &amp; \vdots \ k_{n_01} &amp; \dots  &amp; k_{n_0n_0} &amp; k_{n_0*}\ k_{*1} &amp; \dots &amp; k_{*n_0} &amp; k_{**} \end{matrix} \right]$</p><p>这里的 $K$ 即为原来 $y$ 的协方差矩阵，而 $K_* &#x3D; \left[ \begin{matrix} k_{*1} \ \vdots \ k_{*n_0} \end{matrix} \right]$ </p><p>同理，这里 $u_0(x^*)$ 页数对于任意一个 $x^*$ 来说模型最开始的先验概率均值，当先验确定时，该均值也相应确定。</p><h3 id="final-modeling"><a href="#final-modeling" class="headerlink" title="final modeling"></a>final modeling</h3><p>接下来根据贝叶斯公式：</p><p>$p(y, y_*) &#x3D; p(y_* \vert y)p(y)$</p><p>以及前面的内容推导后得到似然概率密度为：</p><p>$$p(y_* \vert y) &#x3D; N(K_*^T K^{-1}(y-\mu_y), k_{**} - K_<em>^T K K_</em>)$$</p><p>统一写法后即：</p><p>$p(y_* \vert x^*) \sim N\left({K_*^T} {\Sigma_{n_0 * n_0}}^{-1} (y_{n_0} - u_{n_0}), k_{**} - K_<em>^T \Sigma_{n_0 * n_0} K_</em> \right)\ y_{n_0} &#x3D; \left( \begin{matrix} y_1 \ y_2 \ … \ y_{n_0} \end{matrix} \right) \ u_{n_0} &#x3D; \left( \begin{matrix} u_0(x_1) \ u_0(x_2) \ … \ u_0(x_{n_0}) \end{matrix} \right)$</p><p>那么基于当前数据，有先验概率（即上次计算得到的后验概率 $p(y)$），对于每个新的点 $(x^*, y_*)$，都可以通过计算联合高斯密度函数计算出 $p(y, y_*)$，从而计算出 $p(y_* \vert x^*)$</p><h2 id="next-observation"><a href="#next-observation" class="headerlink" title="next observation"></a>next observation</h2><p>当解决了在确认数据下对 $y$ 的概率分布建模后，接下来的关键就是如何确定下一个迭代点 $x_{next}$，前面提到过是通过最大化 $a_n(·)$ 函数来确认。</p><p>关于 $a_n(·)$ 的定义有很多$^{[5]}$：</p><ul><li>Probability of Improvement</li><li><strong>Expected Improvement (EI)</strong> $^{[6]}$</li><li>Minimizing the Conditional Entropy of the Minimizer $^{[7]}$</li><li>the bandit-based criterion $^{[8]}$</li></ul><h3 id="EI"><a href="#EI" class="headerlink" title="EI"></a>EI</h3><p>当前 $y$ 的概率分布已知了，最简单的想法就是选择一个 $x^*$， 使得 $p(y_* \vert x^*)$ 的期望值最大，但这并不一定是一个最好的结果，因为当前算出来的新的后验概率不一定准确，基于均值最大不一定是最好的结果，我们期望得到一个全局最优解。</p><p>因此不去最大化后验均值，而是最大化（后验均值 + 一倍标准差）， 其中加标准差的目的是为了增加可探索性，因为标准差越大，则代表该点的y值会有更大概率取得一个较大的值（但同理也会取得一个更小的值），所以acquisition function 可以理解为一个效用函数，权衡当前已有的结果以及探索的可能。</p><h2 id="figure-example"><a href="#figure-example" class="headerlink" title="figure example"></a>figure example</h2><p>figure example on bayesian optimization$^{[7]}$​</p><ul><li><p>suppose</p><ul><li><p>we are trying to optimize a single hyperparameter which we have displayed on the x-axis.</p></li><li><p>and also we suppose that there is an objective function that we want to minimize and this is displayed on the y-axis </p></li><li><p>the dots denote what we have observed before</p></li></ul></li><li><p>what we do in bayesian optimization is we fit a surrogate model to these observations which is going to predict the objective function value for the hyperparameter value x</p></li><li><p>the curve here is the mean and the shaded areas display uncertainty about given points</p><ul><li>at point at which we have directly evaluated or observed the real or underlying objective function, the uncertainty is zero </li><li>so we can see in the point, the uncertainty is very low. as we move further and further away from observation, the uncertainty around the predictions actually increase which is logical because we have not explored points in that area.</li></ul></li><li><p>once we have the model, we can compute acquisition function which tell us how promising different areas of this hyperparameter space are</p><ul><li>once we have computed this we can actually select new points accordingly</li><li>as the uncertainty increases, the acquisition function also tends to increase a bit</li></ul></li></ul><p><img src="/2024/06/20/automl-paper-survey/image-20240627162942070.png" alt="image-20240627162942070"></p><h2 id="pros"><a href="#pros" class="headerlink" title="pros"></a>pros</h2><ul><li><strong>scalability</strong> &#x3D;&gt; do not typically scale well to high dimensions and exhibit cubic complexity in the number of data points </li><li><strong>flexibility</strong> &#x3D;&gt; do not apply to complex configurations spaces without special kernels</li><li><strong>robustness</strong> &#x3D;&gt; require carefully-set hyper-priors</li></ul><h1 id="SMAC"><a href="#SMAC" class="headerlink" title="SMAC"></a>SMAC</h1><p>as we mentioned before, if we use Gaussian process as the surrogate model, it can only support numerical hyperparameters. as for other SMBO algorithm, they all have <strong>3 key limitations</strong></p><ul><li>only support <strong>numerical hyperparameters</strong>, which is the same as GP</li><li>only optimizes target algorithm performance <strong>for single instances</strong></li><li>lacks a mechanism for <strong>terminating poorly performing target algorithm runs</strong> early (except successive halving and its extension hyperband)</li></ul><p>in order to address first two limitation, SMAC thus make SMBO applicable to general algorithm configuration problems with <strong>many categorical parameters</strong> and sets of benchmark instances</p><h2 id="idea-3"><a href="#idea-3" class="headerlink" title="idea"></a>idea</h2><blockquote><p>suppose there are some sampled configurations with their performance under fixed dataset, ${ (x_1, f(x_1)), (x_2, f(x_2)), \dots, (x_n, f(x_n)) }$. </p></blockquote><p>what <strong>SMAC</strong> do is do fit a model $f$​ <strong>based on random forest</strong>, it’s <u>likened to a multidimensional normal distribution formed by n observations in the Gaussian process</u>.</p><p>since random forests can handle discrete variables, this method naturally lends itself to cases where the variables are <strong>discrete</strong> (categorical). for scenarios involving <strong>conditional constraints</strong>, it is only necessary to incorporate these constraints into the parameter space to <strong>ensure that certain impossible situations are not sampled</strong>.</p><h2 id="modeling-process"><a href="#modeling-process" class="headerlink" title="modeling process"></a>modeling process</h2><p>in the Gaussian regression process, for a newly added point x forming a new multidimensional normal distribution with previous points, <strong>solving the marginal distribution</strong> of the newly added point yields its <strong>mean and standard deviation.</strong> </p><p>how is this achieved in the random forest model is that for a new point x, there is <strong>a prediction result on each tree</strong> in the random forest. <strong>averaging</strong> the prediction results of all trees <strong>yields the mean</strong>, and calculating the standard deviation of the prediction results gives the standard deviation. </p><p>another advantage of random forests is that for a point x, the prediction <strong>complexity</strong> on each tree is only <strong>$O(logN)$</strong>, whereas in the Gaussian regression process, complex matrix multiplication is required to obtain the mean and standard deviation.</p><h2 id="next-observation-1"><a href="#next-observation-1" class="headerlink" title="next observation"></a>next observation</h2><ul><li>select the <strong>top 10</strong> points in the current data set that maximize the acquisition function as starting points</li><li><strong>find neighboring points using the random neighbors method</strong>, and make predictions using the random forest model.<ul><li>random neighbors for a specific point &#x3D;&gt; </li><li>randomly switching the values of all its <strong>discrete variables</strong></li><li>sampling the <strong>continuous variable</strong>s with a mean equal to the current value and a standard deviation of 0.2 (continuous variables were normalized to [0,1] beforehand)</li></ul></li><li>by randomly sampling 10,000 points using this method, predicting their <strong>mean and standard deviation</strong> with the random forest</li><li>calculating the acquisition function, and selecting the point with the highest value as the next iteration point</li></ul><h1 id="TPE"><a href="#TPE" class="headerlink" title="TPE"></a>TPE</h1><p>tree parzen estimator</p><h2 id="definition-4"><a href="#definition-4" class="headerlink" title="definition"></a>definition</h2><p>instead of modeling the <strong>performance of given hyperparameter value</strong> $p(y \vert x)$, what we do in TPE is that we <strong>model the opposite</strong></p><ul><li>model the probability of observing a given hyperparameter value x given a certain loss value (or performance)</li><li>$p(x \vert y)$</li><li>x &#x3D; value of <strong>single</strong> hyperparameter</li><li>y &#x3D; loss (performance)</li></ul><p>maintain <strong>two surrogate models</strong></p><ul><li>a distribution for <strong>bad</strong> values &#x3D;&gt;  $p(x \vert y &gt; y^*) &#x3D; p(x \vert bad)$​<ul><li>$p(x \vert y &gt; y^*)$ means the probability distribution over the hyperparameter values given the loss y was worse than the threshold $y^*$ that we have determined</li><li>also can write as the probability of observing  hyperparameter value when given that the performance is bad</li></ul></li><li>a distribution for <strong>good</strong> values &#x3D;&gt; $p(x \vert y \leq y^*) &#x3D; p(x \vert good)$</li><li>here the threshold <strong>determines good&#x2F;bad</strong> split and it’s <strong>determined by hyperparameter $\gamma$​</strong><ul><li>suppose have 100 different observations and the gamma is set to 0.5, this means that we take the best 50 observations in order to fit the good distribution and we use the 50 worse to fit the bad distribution</li></ul></li></ul><p>get <strong>new promising candidates</strong> &#x3D;&gt; a promising candidate is likely to</p><ul><li>have <strong>low</strong> probability under the bad distribution $p(x \vert bad)$</li><li>have <strong>high</strong> probability under the good distribution $p(x \vert good)$</li><li><strong>promisingness</strong> $\varpropto \frac{p(x \vert good)}{p(x \vert bad)}$<ul><li>the promising score of a hyperparameter value x can be computed as the <strong>ratio between these two</strong> probabilities</li><li>according to the equation, promisingness score increases when the probability under the bad distribution is low or the probability under the good distribution is high</li><li>this result is actually <strong>proportional to the expected improvement (EI)</strong></li><li>the author use this promisingness to <strong>take place of normal EI as a new acquisition function</strong></li></ul></li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><blockquote><p>the blue plot denotes the objective function we want to minimize and there are some points we have observed for the good group and bad group accordingly. </p></blockquote><p>what TPE do is to <strong>fit a probability distribution for the good observations (green circle) and one for the bad observations (orange cross)</strong> </p><blockquote><p>the second image shows these two distribution we fit. here EI denotes no longer normal EI but the promisingness we have defined using two distributions before</p></blockquote><p>we can find that the probability of the <strong>bad group is higher</strong> at the point where we have actually made observations (approximately x &#x3D; 0.5 in the second image), so we will <strong>not select history observations</strong> as the next new observation since in this iterate it’s <strong>promisingness is quite low</strong> due to the high probability under the bad distribution </p><img src="/2024/06/20/automl-paper-survey/image-20240827201109456.png" alt="image-20240827201109456" style="zoom:80%;"><p>after we have <strong>chosen the configuration we want to evaluate next</strong> (maximum value of EI, approximately -0.1 in the image), we now again <strong>compute our good and bad group based on the value of gamma</strong> (re-evaluate which point belong to the good group and which point belongs to the bad one), and <strong>again fit the two distributions</strong>, then <strong>compute the expected improvement again</strong> </p><h2 id="types-of-distribution-used"><a href="#types-of-distribution-used" class="headerlink" title="types of distribution used"></a>types of distribution used</h2><p>depends on the <strong>type of the hyperparameter</strong></p><ul><li>categorical &#x3D;&gt; categorical distribution (point mass frequency)</li><li>real-valued&#x2F;integer<ul><li>sample in original space &#x3D;&gt; <strong>mixture</strong> of <strong>truncated</strong> Gaussians</li><li>sample in log-space &#x3D;&gt; <strong>mixture</strong> of <strong>truncated</strong> Gaussians in log-space<ul><li><u>what is the mixture really is</u></li><li><u>why should use truncated distribution</u> &#x3D;&gt; in the previous hyperparameter optimization as well as in random search we actually specify the admissible range of values over which we want to search and we want to be able to do the same for TPE, so we want to be able to say this is the minimum value or this is the maximum value and go find something in between. By truncating these distributions we can enforce this constraint so that the values outside of this range automatically get assigned a probability of zero</li></ul></li></ul></li></ul><h3 id="about-mixture"><a href="#about-mixture" class="headerlink" title="about mixture"></a>about mixture</h3><blockquote><p>suppose there are 3 observations</p></blockquote><p>what TPE does is that it’s going to fit a Gaussian to every one of these points. </p><ul><li>so every observation will get a Gaussian fitted to it <strong>with the mean equivalent to its hyperparameter value.</strong> </li><li>the <strong>standard deviations of these Gaussians set</strong> are equal to the <strong>maximum distance between</strong> the right or the left <strong>neighbor</strong></li></ul><p>after every value have their own different Gaussian distribution, now we can <strong>mix these distribution</strong> in order to end up with <strong>a single distribution</strong> </p><p>if we want to <strong>compute the mixture probability density at a point</strong>, we just need to first compute its density under each original Gaussian distribution and then normalize by the number of gaussians so that it stays a valid probability</p><h2 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h2><ul><li>easily supports mixed continuous and iscreate spaces due to the nature of kernel density estimators</li><li>model construction scales linearly in the number of data points in contrast to the cubic-time Gaussian processes predominant in the BO literature</li></ul><h1 id="BOHB"><a href="#BOHB" class="headerlink" title="BOHB"></a>BOHB</h1><ul><li><strong>vanilla bayesian optimization</strong> is typically computationally infeasible</li><li><strong>Bandit-bansed</strong> configuration evaluation approach <strong>based on random search</strong> lack guidance and do not converge to the best configurations as quickly</li></ul><p>what bohb to do is to <strong>combine</strong> the benefits of these two methods (in particular, hyperband)  </p><p>&#x3D;&gt; model-based hyper band, <u>strong anytime performance and fast convergence to optimal configurations</u></p><h2 id="idea-4"><a href="#idea-4" class="headerlink" title="idea"></a>idea</h2><p>BOHB relies on HB to determine how many configurations to evaluate with which budget, but it <strong>replaces the random selection of configurations</strong> at the beginning of each HB iteration <strong>by a model-based search</strong></p><ul><li>once the desired number of configurations for the ieration is reached, the standard successive halving procedure is carried out using these configurations.</li><li>we keep track of the performance of all function evaluations $g(x, b) + \epsilon$<ul><li>here $x$ denotes configurations</li><li>$b$ denotes the budget</li><li>and $\epsilon$ denotes the basis of the model</li></ul></li></ul><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>closely resembles TPE, with only one major difference.</p><blockquote><p>Image below shows the initial configuration selection procedure of BOHB</p></blockquote><p>![截屏2024-09-01 23.03.55](.&#x2F;automl-paper-survey&#x2F;截屏2024-09-01 23.03.55.png)</p><p>here</p><ul><li><p>$d$ denotes the number of hyperparameter</p></li><li><p>$N_{min}$ denotes <strong>the minimum number of data points to build the selection model</strong>, in this paper the author set to $d+1$ for experiments</p></li><li><p>$\vert D_b \vert$ denotes the number of observations $D$ of the input for budget $b$</p></li><li><p>$l(x) &#x3D; KDEs$, $l’(x) &#x3D; b_w · l(x)$</p></li><li><p>Promisingness &#x3D; $\frac{l(x)}{g(x)}$</p></li></ul><p>Then</p><ul><li><p>we opt for <strong>a single multidimensional KDE</strong> compared to the hierarchy of one-dimensional KDEs used in TPE in order to better handle interaction effects in the input space</p><ul><li>so the <strong>keypoint here is to fit a useful KDEs</strong></li></ul></li><li><p>to build the model as early as possible, we do not wait until $N_b$ equal to the number of observations $\vert D_b \vert$ for budget $b$ which we input.</p><ul><li><p>instead, we initialize with $N_{min} + 2$ random configurations first</p></li><li><p>we set</p><ul><li>$N_{b, l} &#x3D; \max (N_{min}, q · N_b)$ where $q$ denotes the percentile which is the  input of the algorithm</li><li>$N_{b, g} &#x3D; \max (N_{min}, N_b - N_{b, l})$</li><li>here the <strong>first one denotes number of best configurations</strong> and the second denotes the worst one, since we use <strong>TPE method</strong> as the BO part </li><li><u>this step is equal to re-evaluating good points and bad points in TPE</u></li></ul></li><li><p>then we fit the KDEs ( $l(x)$, $g(x)$ ) according to the TPE method and $N_{b, l}, N_{b, g}$</p><ul><li><u>this step is equal to model the densities (fit two distribution) in TPE</u></li></ul></li><li><p>after we fit the $l(x)$,  we need to determine the configurations sampling parameter according to $l(x)$, we do not use $l(x)$ directly, instead</p><ul><li>we multiply it by a factor $b_w$ to encourage more exploration and we call it $l’(x)$ </li><li>then we sample $N_s$ points from $l’(x)$ as the sampling result</li><li>keep track of the promisingness and its sampling result of this iteration</li></ul></li><li><p><strong>return</strong> the sampling results with highest ratio (promisingness)</p></li></ul></li></ul><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol><li>AutoML: A survey of the state-of-the-art</li><li><a href="https://zhuanlan.zhihu.com/p/139605200">https://zhuanlan.zhihu.com/p/139605200</a></li><li>Bergstra, J., Bardenet, R., Bengio, Y., and Kégl, B. Algorithms  for hyper-parameter optimization. In Advances in Neural Information  Processing Systems, 2011.</li><li>Hutter, F., Hoos, H., and Leyton-Brown, K. Sequential modelbased  optimization for general algorithm conﬁguration. In Learning and  Intelligent Optimization, volume 6683, 2011.</li><li>D.R. Jones. A taxonomy of global optimization methods based on response surfaces. Journal of Global Optimization, 21:345–383, 2001.</li><li>J. Villemonteix, E. Vazquez, and E. Walter. An informational approach to the global optimization of expensive-to-evaluate functions. Journal of Global Optimization, 2006.</li><li>N. Srinivas, A. Krause, S. Kakade, and M. Seeger. Gaussian process optimization in the bandit setting: No regret and experimental design. In ICML, 2010.</li><li>A Tutorial on Bayesian Optimization of Expensive Cost Functions, with Application to Active User Modeling and Hierarchical Reinforcement Learning</li><li>amieson, K. and Talwalkar, A. Non-stochastic best arm  identiﬁcation and hyperparameter optimization. In Conference on  Artiﬁcial Intelligence and Statistics, 2016.</li><li>Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A., and  Talwalkar, A. Hyperband: Bandit-based conﬁguration evaluation for  hyperparameter optimization. In International Conference on Learning  Representations, 2017.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://elubrazione.github.io/2024/03/18/algorithm-backtracking/"/>
    <id>https://elubrazione.github.io/2024/03/18/algorithm-backtracking/</id>
    <published>2024-03-18T07:12:35.000Z</published>
    <updated>2024-03-19T02:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法</p><span id="more"></span><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="[77] 组合"></a><a href="https://leetcode.cn/problems/combinations/description/">[77] 组合</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>基础版本代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> idx, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt;= n; i++) &#123;</span><br><span class="line">      path.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="built_in">backtracking</span>(k, i + <span class="number">1</span>, n);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(k, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是以上方法不够高效，当循环到当前数目且后面所有元素的总个数也不够k的时候，就可以进行剪枝。目前已经选择了的个数是 <code>path.size()</code>，那么还需要 <code>k - path.size()</code> 个元素。假设起始位置为x，终止为n，可得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n - x + 1 &gt;= k - path.size()</span><br><span class="line">x &lt;= n + 1 - k + path.size()</span><br><span class="line">即 i &lt;= n + 1 - k + path.size()</span><br></pre></td></tr></table></figure><p>因此最后的代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> idx, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt;= n &amp;&amp; i &lt;= n + <span class="number">1</span> - k + path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      path.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="built_in">backtracking</span>(k, i + <span class="number">1</span>, n);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(k, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="[39] 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/description/">[39] 组合总和</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>重点：无重复元素但是元素可以被无限选取，但是问的是组合数，所以要进行去重，同时每次回溯的i不变。</p><p>先进行排序，然后在for循环里判断当前元素是否和上一个一样，如果一样则说明重复了，则可以直接跳过本层循环。</p><p>同时可以进行剪枝，因为排序过了，如果加上当前元素已经超过了target则说明没必要继续搜索，直接break即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">      <span class="built_in">backtracking</span>(candidates, target - candidates[i], i);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和Ⅱ"><a href="#40-组合总和Ⅱ" class="headerlink" title="[40] 组合总和Ⅱ"></a><a href="https://leetcode.cn/problems/combination-sum-ii/description/">[40] 组合总和Ⅱ</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>和上一题差不多，有重复元素和没重复元素但是可以无限次选择没什么区别，都是先排序然后判断和上一个元素是否相同，只不过这题idx在回溯里需要加1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">      <span class="built_in">backtracking</span>(candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="216-组合总和Ⅲ"><a href="#216-组合总和Ⅲ" class="headerlink" title="[216] 组合总和Ⅲ"></a><a href="https://leetcode.cn/problems/combination-sum-iii/description/">[216] 组合总和Ⅲ</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>是70组合和39组合总和的叠加版本，限制了元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt;= <span class="number">10</span> - k + path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n - i &lt; <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">      path.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="built_in">backtracking</span>(k, n - i, i + <span class="number">1</span>);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="[131] 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">[131] 分割回文串</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 回文串。返回 <code>s</code> 所有可能的分割方案。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>假设当前的初始位置为<code>idx</code>，用for循环遍历到 <code>s.size() - 1</code> 每个位置 <code>s[idx: i]</code> 当前子串是不是回文，如果是回文则进行一次切割加入res，并从下一个位置开始继续纵向搜索，如此递归。</p><p>而如果当前位置 <code>i</code> 和起始位置 <code>idx</code> 组成的子串不是回文，则要继续通过for循环横向寻找下一个满足的位置 <code>i</code>。如果本次循环都不满足则根本不会到 <code>idx &gt;= s.size()</code>，循环会在最后的 <code>i &lt; s.size()</code> 直接退出并返回上一层，而上一层做的是将之前切割的部分子串 <code>pop_back()</code> 出去。</p><p>也就是只有前面所有切割位置都是回文，才会纵向往下达到 <code>idx &gt;= s.size()</code> 的递归边界条件。</p><p>这里的判断回文子串可以直接用一个二维的dp数组一次完成，后续只需要根据 <code>idx</code> 和 <code>i</code> 的值查询保存的dp数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;string&gt; res;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; dp;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">isPalindrome</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == d[j]</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    dp.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]))</span><br><span class="line">          dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dp[idx][i])  <span class="keyword">continue</span>;</span><br><span class="line">      string str = s.<span class="built_in">substr</span>(idx, i - idx + <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">push_back</span>(str);</span><br><span class="line">      <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    <span class="built_in">isPalindrome</span>(s);</span><br><span class="line">    <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="[93] 复原IP地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">[93] 复原IP地址</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>开一个变量用来计算目前已经加入的结果的数量，如果到达了3最后一段另外处理，这样有两个好处：</p><ul><li>不用特判处理中间的 <code>.</code> 符号；</li><li>可以大量剪枝，前面加入了三段后最后一段可以直接特判不再进行切分，省掉很多时间。</li></ul><p>另一个剪枝点是每一个for循环最多只需要往后判断三位，超过三位肯定不满足</p><p><code>isValid()</code> 函数里需要判断的所有情况如下：</p><ul><li><code>start &gt; end</code>：是因为可能出现三段把字符串都分完，最后start为<code>s.size()</code>，但是end是固定的<code>s.size() - 1</code></li><li><code>end - start &gt; 2</code>：长度超过三肯定不满足</li><li><code>s[start] == &#39;0&#39; &amp;&amp; start != end</code>：不为0但是以0开头</li><li>以上通过后计算结果值是否小于255即可</li></ul><p>因为判断是否满足条件时只需要用到一些简单的条件而不用对字符串进行实际的切分，所以可以等真的满足条件valid之后再进行切分，省掉时间，即不要提早切分。</p><p>这题总体的格式和上题目一样，只是在for循环深度backtracking前加入了一个if判断语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  vector&lt;string&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> idx, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, idx, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res + s.<span class="built_in">substr</span>(idx, s.<span class="built_in">size</span>() - idx));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; idx + <span class="number">3</span> &amp;&amp; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 最多只需往后验证三位</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, idx, i)) &#123;</span><br><span class="line">        string str = s.<span class="built_in">substr</span>(idx, i - idx + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span>, tmp = res;</span><br><span class="line">        res += str;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">        res = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || end - start &gt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">      num = (s[i] - <span class="string">&#x27;0&#x27;</span>) + num * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="[78] 子集"></a><a href="https://leetcode.cn/problems/subsets/description/">[78] 子集</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>和组合类型差不多，只不过需要每次递归都添加一次res</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">      <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="90-子集Ⅱ"><a href="#90-子集Ⅱ" class="headerlink" title="[90] 子集Ⅱ"></a><a href="https://leetcode.cn/problems/subsets-ii/description/">[90] 子集Ⅱ</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p>经典有重复元素排序+去重，核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; idx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; idx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">      res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">      <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="[46] 全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">[46] 全排列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><p>因为是排列所以不需要idx了，每次从0开始遍历，但是需要used数组来判断一下当前数字使用过没有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res, used;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i])  <span class="keyword">continue</span>;</span><br><span class="line">      res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">      used[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">backtracking</span>(nums, n);</span><br><span class="line">      res.<span class="built_in">pop_back</span>();</span><br><span class="line">      used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    used.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排列Ⅱ"><a href="#47-全排列Ⅱ" class="headerlink" title="[47] 全排列Ⅱ"></a><a href="https://leetcode.cn/problems/permutations-ii/description/">[47] 全排列Ⅱ</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给定一个可包含重复数字的整数集合 <code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><p>有重复的元素因此要去重，仍然是排序加上判断相邻节点状态。</p><blockquote><p>以下内容来自代码随想录</p></blockquote><p>去重最为关键的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>**如果改成 <code>used[i - 1] == true</code>， 也是正确的!**，去重代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p><p>用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] &#x3D;&#x3D; false)，的树形结构如下：</p><p><img src="/2024/03/18/algorithm-backtracking/20201124201406192.png" alt="47.全排列II2"></p><p>树枝上去重（used[i - 1] &#x3D;&#x3D; true）的树型结构如下：</p><p><img src="/2024/03/18/algorithm-backtracking/20201124201431571.png" alt="47.全排列II3"></p><p>树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res, used;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i])  <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !used[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">      used[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">backtracking</span>(nums, n);</span><br><span class="line">      res.<span class="built_in">pop_back</span>();</span><br><span class="line">      used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    used.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h1><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="[51] N皇后"></a><a href="https://leetcode.cn/problems/n-queens/description/">[51] N皇后</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><p>重点在于检查同一列和和检查斜对角线，见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;string&gt; res;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不用检查同一行，因为每次放置完都回溯，同一行不可能有多个皇后</span></span><br><span class="line">    <span class="comment">// 同一列上不能有皇后，检查列，查找上面的行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (res[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查右上的斜对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)</span><br><span class="line">      <span class="keyword">if</span> (res[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查左上角的斜对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">      <span class="keyword">if</span> (res[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, n)) &#123;</span><br><span class="line">        res[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(row + <span class="number">1</span>, n);</span><br><span class="line">        res[row][col] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 回溯</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    res.<span class="built_in">resize</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    <span class="built_in">backtracking</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="[37] 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/description/">[37] 解数独</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">char</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查同一行有没有相同的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">      <span class="keyword">if</span> (board[row][i] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查同一列有没有相同的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">8</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (board[i][col] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查九宫格</span></span><br><span class="line">    <span class="type">int</span> r = (row / <span class="number">3</span>) * <span class="number">3</span>, c = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; r + <span class="number">3</span>; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt; c + <span class="number">3</span>; j++)</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, board, k)) &#123;</span><br><span class="line">              board[i][j] = k;</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 如果找到成功的立刻返回</span></span><br><span class="line">              <span class="comment">// 没找到失败了，撤销一下刚才的填写</span></span><br><span class="line">              board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(board);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;回溯算法&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://elubrazione.github.io/2024/03/14/algorithm-mst/"/>
    <id>https://elubrazione.github.io/2024/03/14/algorithm-mst/</id>
    <published>2024-03-14T04:50:43.000Z</published>
    <updated>2024-03-14T07:46:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>算法笔记</p><span id="more"></span><h1 id="三个性质"><a href="#三个性质" class="headerlink" title="三个性质"></a>三个性质</h1><ul><li>最小生成树是树，其边树等于顶点树减去1，且树内一定不会有环</li><li>对给定的图$G(V,E)$，其最小生成树不唯一，但是边权值和一定唯一</li><li>最小生成树是在无向图上生成的，因此根节点可以是任意一个节点</li></ul><p>求法有Kruskal和prim，都是基于贪心算法</p><ul><li>kruskal稀疏图，复杂度主要来源于对边的排序</li><li>prim稠密图，复杂度主要来源于顶点</li></ul><h1 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>设置集合S，存放已被访问的顶点，然后每次从集合$V-S$中选择与集合$S$的最短距离最小的一个顶点$u$，访问并加入集合$S$。之后令顶点$u$为中介点，优化所有从$u$能到达的顶点$v$与集合$S$之间的最短距离。</p><p>这样执行n次后直到集合已包含所有的顶点，此思想和Dijkstra几乎相等，只是在设计最短距离时使用了集合$S$代替Dijkstra算法中的起点s。</p><h2 id="两个要点"><a href="#两个要点" class="headerlink" title="两个要点"></a>两个要点</h2><ul><li>集合$S$的实现 &#x3D;&gt; 用一个bool数组vis[]表示顶点是否已经被访问</li><li>顶点$V_i$与集合$S$的最短距离 &#x3D;&gt; 用int数组d[]来存放最短距离</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="邻接矩阵版本"><a href="#邻接矩阵版本" class="headerlink" title="邻接矩阵版本"></a>邻接矩阵版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, G[maxv][maxv], d[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), inf);</span><br><span class="line">  d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">// 存放最小生成树的边权值和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">-1</span>, mx = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; mx) &#123;</span><br><span class="line">        u = j;</span><br><span class="line">        mx = d[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ans += d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">      <span class="comment">// v还未访问 &amp;&amp; u能到达v &amp;&amp; 以u为中介点可以使得v离集合S更近</span></span><br><span class="line">      <span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf &amp;&amp; G[u][v] &lt; d[v]) &#123;</span><br><span class="line">        d[v] = G[u][v];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表版本"><a href="#邻接表版本" class="headerlink" title="邻接表版本"></a>邻接表版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, dis;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="type">int</span> n, d[maxv];</span><br><span class="line"><span class="type">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), inf);</span><br><span class="line">  d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">-1</span>, mx = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; mx) &#123;</span><br><span class="line">        u = j;</span><br><span class="line">        mx = d[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ans += d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: Adj[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[p.v] == fasle &amp;&amp; p.dis &lt; d[v]) &#123;</span><br><span class="line">        d[v] = p.dis;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h1><blockquote><p>采用基于边贪心的策略</p></blockquote><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p><img src="/2024/03/14/algorithm-mst/image-20240314132013529.png" alt="image-20240314132013529"></p><h2 id="两个要点-1"><a href="#两个要点-1" class="headerlink" title="两个要点"></a>两个要点</h2><ul><li>如何判断两个端点在不同的连通块中 &#x3D;&gt; 并查集，查找father数组</li><li>如何讲测试便加入最小生成树 &#x3D;&gt; 并查集，将两个集合合并</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>由于需要判断边的两个端点是否在不同的连通块中，因此百年的两个端点的编号一定是需要的，然后再加上边权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXE = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  <span class="type">int</span> cost;</span><br><span class="line">&#125; E[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[MAXV];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = x;</span><br><span class="line">  <span class="keyword">while</span> (father[x] != x) &#123;</span><br><span class="line">    x = father[x];</span><br><span class="line">  &#125;<span class="comment">// 找到顶层 =&gt; x</span></span><br><span class="line">  <span class="keyword">while</span> (a != father[a]) &#123;<span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="type">int</span> z = a;</span><br><span class="line">    a = father[a];</span><br><span class="line">    father[z] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n是顶点数，m是边数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    father[i] = i;<span class="comment">// 并查集初始化</span></span><br><span class="line">  <span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(), [&amp;](edge a, edge b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p: E) &#123;</span><br><span class="line">    <span class="type">int</span> faU = <span class="built_in">findFather</span>(p.u);</span><br><span class="line">    <span class="type">int</span> faV = <span class="built_in">findFather</span>(p.v);</span><br><span class="line">    <span class="keyword">if</span> (faU != faV) &#123;<span class="comment">// 不是一个连通分量</span></span><br><span class="line">      father[faU] = faV;</span><br><span class="line">      ans += p.cost;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="keyword">if</span> (cnt == n - <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;算法笔记&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划股票买卖问题</title>
    <link href="https://elubrazione.github.io/2024/03/09/algorithm-dp-stock/"/>
    <id>https://elubrazione.github.io/2024/03/09/algorithm-dp-stock/</id>
    <published>2024-03-09T08:18:00.000Z</published>
    <updated>2024-03-18T15:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">[121] 买卖股票的最佳时机</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][0]表示第i天持有股票：</span></span><br><span class="line"><span class="comment">// 那么有可能是i-1天就持有今天保持dp[i-1][0]，也有可能是昨天没有但是今天买入-prices[i](只允许买卖一次所以不继承前面的状态)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][1]表示第i天不持有股票</span></span><br><span class="line"><span class="comment">// 那么有可能是i-1天就不持有今天保持dp[i-1][1]，也有可能是昨天有但是今天卖出dp[i-1][0] + prices[i]</span></span><br><span class="line"><span class="comment">// dp[0][0] = -prices[i]，dp[0][1] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为只依赖于前一天的值所以可以使用滚动数组来做，dp[0]要放在后面更新，因为dp[1]依赖于上一条的dp[0]的值</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i]);</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机Ⅱ"><a href="#122-买卖股票的最佳时机Ⅱ" class="headerlink" title="[122] 买卖股票的最佳时机Ⅱ"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">[122] 买卖股票的最佳时机Ⅱ</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相比于上一题可以购买多次</span></span><br><span class="line"><span class="comment">// 持有股票：dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</span></span><br><span class="line"><span class="comment">// 不持有股票：dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</span></span><br><span class="line"><span class="comment">// 初始化 =&gt; dp[0] = -prices[i]</span></span><br><span class="line"><span class="comment">// 最后一定是不持有股票</span></span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> t1 = dp[<span class="number">0</span>], t2 = dp[<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], t2 - prices[i]);</span><br><span class="line">      dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], t1 + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机Ⅲ"><a href="#123-买卖股票的最佳时机Ⅲ" class="headerlink" title="[123] 买卖股票的最佳时机Ⅲ"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">[123] 买卖股票的最佳时机Ⅲ</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置四个状态：第一次持有，第一次不持有；第二次持有，第二次不持有</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i-1][0], 0 - prices[i]);</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);</span></span><br><span class="line"><span class="comment">// dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);</span></span><br><span class="line"><span class="comment">// dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成一维，初始化 =&gt; dp[0] = -prices[0], dp[2] = -prices[0];</span></span><br></pre></td></tr></table></figure><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = -prices[<span class="number">0</span>], dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], <span class="number">0</span> - prices[i]);</span><br><span class="line">      dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">      dp[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">      dp[<span class="number">4</span>] = <span class="built_in">max</span>(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时期Ⅳ"><a href="#188-买卖股票的最佳时期Ⅳ" class="headerlink" title="[188] 买卖股票的最佳时期Ⅳ"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">[188] 买卖股票的最佳时期Ⅳ</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>在上一题的基础上加上一个维度即可</p><p><code>dp[k][0]</code>表示第k次持有，<code>dp[k][1]</code>表示第k次不持有</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0持有，1不持有</span></span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 引入第0次跳过特判</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) dp[i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">        <span class="comment">// 第j次持有，那么就是持有保持或者j-1次不持有的基础上这次买入</span></span><br><span class="line">        dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        <span class="comment">// 第j次不持有，那么就是不持有保持或者j次持有然后完成卖出</span></span><br><span class="line">        dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j][<span class="number">0</span>] + prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="[714] 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">[714] 买卖股票的最佳时机含手续费</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><h2 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h2><p>第122题加上一个费用即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>] + fee;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] - prices[i] - fee);</span><br><span class="line">      dp[i % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="309-买卖股票的最佳时期含冷冻期"><a href="#309-买卖股票的最佳时期含冷冻期" class="headerlink" title="[309] 买卖股票的最佳时期含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">[309] 买卖股票的最佳时期含冷冻期</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// dp[i][0]: 手上持有股票的最大收益</span></span><br><span class="line">    <span class="comment">// dp[i][1]: 手上不持有股票，明天不能买</span></span><br><span class="line">    <span class="comment">// dp[i][2]: 手上不持有股票，明天能买</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">      dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://elubrazione.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://elubrazione.github.io/2024/03/06/algorithm-stack-and-queue/"/>
    <id>https://elubrazione.github.io/2024/03/06/algorithm-stack-and-queue/</id>
    <published>2024-03-06T07:07:53.000Z</published>
    <updated>2024-03-18T08:21:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode代码随想录栈与队列专题</p><span id="more"></span><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="[225] 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">[225] 用队列实现栈</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>栈是先进后出，队列先进先出。也就是要把队列最尾巴的元素出队，因此需要把队列前面的所有元素出队然后重新放到队列的后面。所以只需要一个队列即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回队尾元素</span></span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="[232] 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">[232] 用栈实现队列</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>push就正常push；pop的话用另外一个栈来接第一个栈的元素，倒一遍就改变了元素的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">  <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stIn.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">        stIn.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">    stOut.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">pop</span>();</span><br><span class="line">    stOut.<span class="built_in">push</span>(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stIn.<span class="built_in">empty</span>() &amp;&amp; stOut.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="[20] 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/">[20] 有效的括号</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>设置一个哈希表，左括号作为value，右括号作为key。每次遇到左括号就把左括号入栈，并计数。若遇到右括号，判断其和目前栈顶元素是否相同（当然如果栈为空就直接返回false即可，<strong>说明右括号多了</strong>），如果相同就弹出并且计数器减1，不同的话就<strong>说明没匹配上</strong>直接返回false。</p><p>最后还要判断一下计数器num是否为0，不为0就<strong>说明左括号多了</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">&#x27;)&#x27;</span>] = <span class="string">&#x27;(&#x27;</span>, mp[<span class="string">&#x27;&#125;&#x27;</span>] = <span class="string">&#x27;&#123;&#x27;</span>, mp[<span class="string">&#x27;]&#x27;</span>] = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        num++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mp[s[i]] == stk.<span class="built_in">top</span>()) &#123;</span><br><span class="line">          stk.<span class="built_in">pop</span>();</span><br><span class="line">          num--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="[1047] 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">[1047] 删除字符串中的所有相邻重复项</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s[i] != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="[150] 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">[150] 逆波兰表达式求值</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, string c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&quot;-&quot;</span>) <span class="keyword">return</span> b - a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;+&quot;</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;/&quot;</span>) <span class="keyword">return</span> b / a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tokens.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">stoi</span>(tokens[<span class="number">0</span>]);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        ans = <span class="built_in">compute</span>(a, b, tokens[i]);</span><br><span class="line">        st.<span class="built_in">push</span>(ans);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="[239] 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">[239] 滑动窗口最大值</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><p><strong>对于「最大值」，一种非常合适的数据结构那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</strong></p><p>对于本题而言，初始时，将数组 $nums$ 的前 $k$ 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 $nums$ 中的位置出现在滑动窗口左边界的左侧。</p><p>因此，当后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p><p>不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组 $(num,index)$，表示元素 $num$ 在数组中的下标为 $index$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">pair</span>(nums[i], i));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">pair</span>(nums[i], i));</span><br><span class="line">      <span class="comment">// 去除不在滑动窗口之内的元素，假设窗口最左边位置是x</span></span><br><span class="line">      <span class="comment">// 目前是i，i-x+1=k，x=i+1-k，x&lt;i+1-k，因此x&lt;=i-k</span></span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k)q.<span class="built_in">pop</span>();</span><br><span class="line">      ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="[347] 前K个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">[347] 前K个高频元素</a></h1><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><p>先用哈希表统计每个数组出现的频率，然后以出现的&lt;次数, 数字&gt;对的形式存放在优先队列里。最后输出优先队列的前k个元素即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)mp[nums[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">pair</span>(it-&gt;second, it-&gt;first));  <span class="comment">// 次数+数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().second);  <span class="comment">// 数字</span></span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode代码随想录栈与队列专题&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://elubrazione.github.io/2024/02/29/algorithm-two-pointers/"/>
    <id>https://elubrazione.github.io/2024/02/29/algorithm-two-pointers/</id>
    <published>2024-02-29T05:33:03.000Z</published>
    <updated>2024-03-18T08:25:41.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>动态规划背包问题</title>
    <link href="https://elubrazione.github.io/2024/02/07/algorithm-dp-bag/"/>
    <id>https://elubrazione.github.io/2024/02/07/algorithm-dp-bag/</id>
    <published>2024-02-07T09:52:07.000Z</published>
    <updated>2024-03-25T05:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><p>借一下代码随想录的图</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407-20230310132423205.png" alt="背包问题分类"></p><h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="[416] 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">[416] 分割等和子集</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>转换成01背包，背包的容量是sum &#x2F; 2，要放入的物品的重量为nums数组元素的数值，价值也是其数值。如果背包正好装满则说明找到了总和为sum &#x2F; 2的子集。</p><ol><li>dp数组的含义 &#x3D;&gt; dp[i]表示容量为j的背包可装入的最大价值为dp[j]</li></ol><p>如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] &#x3D;&#x3D; target 的时候，背包就装满了。</p><ol start="2"><li>状态转移方程 &#x3D;&gt; dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</li><li>初始化 &#x3D;&gt; dp[0] &#x3D; 0;</li><li>遍历顺序 &#x3D;&gt; <strong>外层物品内层背包容量，外层顺序内层倒序</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="comment">// 如果背包容量小于nums[i]，当前物品就装不下了</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum] == sum? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1049-最后一块石头的重量Ⅱ"><a href="#1049-最后一块石头的重量Ⅱ" class="headerlink" title="[1049] 最后一块石头的重量Ⅱ"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">[1049] 最后一块石头的重量Ⅱ</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><blockquote><p>一堆正的一堆负的，即一堆大的一堆小的。尽量两堆的重量相等所剩的质量才最小。</p></blockquote><p>$\sum \limits ^{n-1} _{i&#x3D;0}k_i ·stones[i] &#x3D; (sum - neg) - neg &#x3D; sum - 2 · neg$</p><p>要使最后一块石头的重量尽可能地小，$\textit{neg}$ 需要在不超过 $\textit{sum}&#x2F;2 $ 的前提下尽可能地大。因此本问题可以看作是背包容量为 $\textit{sum}&#x2F;2 $，物品重量和价值均为 $\textit{stones}[i]$的 0-1 背包问题。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum - dp[target] - dp[target];</span><br></pre></td></tr></table></figure><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="[494] 目标和"></a><a href="https://leetcode.cn/problems/target-sum/description/">[494] 目标和</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>target &#x3D; pos - neg &#x3D; sum - 2 * neg</p><p>neg &#x3D; (sum - target) &#x2F; 2 &#x3D;&gt; 背包容量</p><p>由于<code>0 &lt;= sum(nums[i]) &lt;= 1000</code>，<code>-1000 &lt;= target &lt;= 1000</code>，所以neg是非负整数，所以上式成立的前提是 sum - target 是非负偶数。</p><p>若上式成立，问题转化成在数组nums中选取若干元素，使得这些元素之和等于 neg（装满背包），计算选取元素的方案数，可以使用动态规划的方法求解。</p><p>dp[j] 代表填满容量为j的背包的方案数，只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> diff = sum - target, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    diff /= <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(diff + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = diff; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">        dp[j] += dp[j - nums[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[diff];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="[474] 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">[474] 一和零</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>求最大子集的长度，这里的物品是指每个strs里面的字符串（strs的类型为<code>vector&lt;string&gt;</code>），背包的容量是m和n，每个字符串的重量是其字符串中字符0和字符1的数量，每个字符串的价值为1。</p><p>注意这题不是完全背包，而是01背包，因为每个字符串只能用一次。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j]代表有i个0和j个1的子集个数，这里m和n是背包的容量，只不过是二维的</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs) &#123;  <span class="comment">// 遍历物品</span></span><br><span class="line">      <span class="type">int</span> n1 = <span class="number">0</span>, n0 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> ch: str) &#123;  <span class="comment">// 统计当前物品两个维度的重量</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>)  n0++;</span><br><span class="line">        <span class="keyword">else</span>  n1++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= n0; i--) &#123; <span class="comment">// 遍历第一维度的背包容量，倒序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= n1; j--) &#123; <span class="comment">// 遍历第二位维度的背包容量，倒序</span></span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - n0][j - n1] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><blockquote><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>01背包内嵌的循环是<strong>从大到小</strong>遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要<strong>从小到大</strong>去遍历，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组合数：先物品后容量；</strong></p><p><strong>排列数：先容量后物品。</strong></p></blockquote><h2 id="518-零钱兑换Ⅱ"><a href="#518-零钱兑换Ⅱ" class="headerlink" title="[518] 零钱兑换Ⅱ"></a>[518] 零钱兑换Ⅱ</h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="377-组合总和Ⅳ"><a href="#377-组合总和Ⅳ" class="headerlink" title="[377] 组合总和Ⅳ"></a>[377] 组合总和Ⅳ</h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>正整数且不存在重复数字，找出和为目标整数的排列个数，可以用回溯暴力搜</p><p>这里的数字又可以重复使用，而且只要排列的个数不需要将每个答案都列出来，因此可以用动态规划进行优化。是一个完全背包问题。</p><p>物品是数组里的元素，背包的重量和价值是元素之和，背包容量是target。</p><p>dp[j] 表示目前重量为j的背包里装的方法排列个数，因此 <code>dp[0]</code> 要初始化为1，虽然 <code>dp[0] = 1</code> 是没有任何意义的，只是为了进行递推。</p><p>排列数外层是背包重量，且内层从小到大；内层是物品。</p><p><strong>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[j] &lt; INT_MAX - dp[j - nums[i]]。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span> &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) &#123;</span><br><span class="line">      dp[j] += dp[j - nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-完全爬楼梯"><a href="#70-完全爬楼梯" class="headerlink" title="[70] 完全爬楼梯"></a>[70] 完全爬楼梯</h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。 </p><p>输入描述：输入共一行，包含两个正整数，分别表示n, m </p><p>输出描述：输出一个整数，表示爬到楼顶的方法数。 </p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>物品是 <code>1 ~ m</code> 共m个整数，背包容量是n，且是排列数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>)dp[i] += dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[j] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="[322] 零钱兑换"></a>[322] 零钱兑换</h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://elubrazione.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划子序列问题</title>
    <link href="https://elubrazione.github.io/2024/01/16/algorithm-dynamic-programming/"/>
    <id>https://elubrazione.github.io/2024/01/16/algorithm-dynamic-programming/</id>
    <published>2024-01-16T02:26:49.000Z</published>
    <updated>2024-03-25T05:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><h1 id="不连续子序列问题"><a href="#不连续子序列问题" class="headerlink" title="不连续子序列问题"></a>不连续子序列问题</h1><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="[300] 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">[300] 最长递增子序列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>只有一个字符串 &#x3D;&gt; 一维dp数组</p><p>求递增子序列 &#x3D;&gt; 判断条件即两个树的大小比较</p><p>子序列 &#x3D;&gt; 不需要连续，因此要固定一个位置然后再开循环遍历，双层</p></blockquote><p><strong>动态规划五部曲</strong></p><ol><li>确定dp数组的含义</li></ol><p>dp[i]表示以i为结尾且包括nums[i]的最长严格递增子序列的最长长度</p><ol start="2"><li>确定状态转移方程</li></ol><p>若当前元素nums[j]大于nums[i]，那么以nums[i]为结尾的子序列就可以加上nums[j]，所以长度应该加上1；而如果不大于那么就保持原值即可。我们需要遍历每个小于j的i的值，比较并更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[i])dp[j] = <span class="built_in">max</span>(dp[j], dp[i] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>如何初始化dp数组</li></ol><p>对于每个dp[j]最初都至少包含了自己，即1</p><ol start="4"><li>如何遍历</li></ol><p>外层循环固定j表示每一个位置，然后内层循环遍历i，i应该是从0到j-1以此来更新以nums[j]为结尾的子序列的长度</p><ol start="5"><li>拿个例子推导一下</li></ol><img src="/2024/01/16/algorithm-dynamic-programming/image-20240304215613285.png" alt="image-20240304215613285" style="zoom:80%;"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">          dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="[1143] 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">[1143] 最长公共子序列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的<strong>公共子序列</strong>是这两个字符串所共同拥有的子序列。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><ol><li>确定dp数组的含义</li></ol><p><code>dp[i][j]</code> 表示对于text1的0到i-1的子串和text2的0到j-1的子串的最长公共子序列的长度</p><ol start="2"><li>确定状态转移方程</li></ol><p>公共 &#x3D;&gt; 判断两个数字是否相同。如果相同，就是上一个<code>dp[i - 1][j - 1]</code>的公共长度加上1</p><p>​&#x3D;&gt; 不相同，<strong>继承上一个状态的最大值</strong>，上一个状态是0到i-2和0到j-1（左边一格）的公共子序列长度 以及 0到i-1和0到j-2（右边一格）的公共子序列长度 中的较大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">  dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如何初始化dp数组</li></ol><p>0下标表示空串，text1和空串公共子序列长度为0，text2同理，所以初始化全为0。</p><ol start="4"><li>如何遍历</li></ol><p>从小到大遍历</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text<span class="number">1.</span><span class="built_in">size</span>(), m = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;<span class="comment">// 注意dp数组的含义</span></span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="[1035] 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/description/">[1035] 不相交的线</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>上一道题目（1143）套皮，本质是一道题</p><h1 id="连续子序列问题"><a href="#连续子序列问题" class="headerlink" title="连续子序列问题"></a>连续子序列问题</h1><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="[674] 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">[674] 最长连续递增序列</a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><ol><li>dp数组的含义</li></ol><p>dp[i]表示以i结尾下标包含nums[i]连续递增子序列的最长长度</p><ol start="2"><li>状态转移方程</li></ol><p>递增 &#x3D;&gt; 判断后面是否大于前面</p><p>连续 &#x3D;&gt; 不用固定再遍历，只需要简单比较前一位即可，因此只需要一层循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>最短都是自己，因此都初始化为1</p><ol start="4"><li>如何遍历</li></ol><p>依赖前一个，从前往后遍历</p><ol start="5"><li>推导例子</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="[718] 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">[718] 最长重复子数组</a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><ol><li>dp数组的含义</li></ol><p><code>dp[i][j]</code>表示nums1[i - 1]和nums2[j - 1]的最长公共子数组</p><ol start="2"><li>状态转移方程</li></ol><p>公共 &#x3D;&gt; 判断两个元素是否相等，不相等则为0，因为要是连续的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums[j - <span class="number">1</span>])</span><br><span class="line">  dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  dp[i][j] = <span class="number">0</span>;<span class="comment">//  这个可以省去不写，因为默认就是0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>下标0表示空数组，所以<code>dp[i][0]</code> &#x3D; 0, <code>dp[0][j]</code> &#x3D; 0</p><ol start="4"><li>如何遍历</li></ol><p>从前往后双层遍历，都从1开始，需要一个res来保存</p><ol start="5"><li>推导例子</li></ol><img src="/2024/01/16/algorithm-dynamic-programming/image-20240305115021176.png" alt="image-20240305115021176" style="zoom:80%;"><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>(), m = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">       res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">[53] 最大子序和</a></h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><ol><li>dp数组的含义</li></ol><p>dp[i]表示以i为结尾包含nums[i]元素的连续子数组的最大和</p><ol start="2"><li>状态转移方程</li></ol><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和（类比最长连续递增取1，但是因为本身就是1所以判断完不用写else语句）</li></ul><p>一定是取最大的，所以dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</p><ol start="3"><li>初始化 &#x3D;&gt; dp[i]初始化为nums[i]（类比那个最长连续递增初始化为1），但是我们可以用递推公式免去除了0以外的初始化</li><li>遍历顺序 &#x3D;&gt; 从小到大遍历</li><li>推导一遍例子</li></ol><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">      res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="距离问题"><a href="#距离问题" class="headerlink" title="距离问题"></a>距离问题</h1><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="[392] 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/description/">[392] 判断子序列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen.svg" alt="LeetCode Easy" style="text-align: left;"></div><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><ol><li>确认dp数组含义</li></ol><p>s是t的子序列，<code>dp[i][j]</code>代表s[i - 1]是否是t[j - 1]的子序列</p><ol start="2"><li>状态转移方程</li></ol><p>判断当前s[i - 1]是否和t[j - 1]相等，如果相等且<code>dp[i - 1][j - 1] == true</code>，则<code>dp[i][j]</code>也为true，所以就是如果相等的话<code>dp[i][j]</code>的值取决于<code>dp[i - 1][j - 1]</code></p><p>如果不相等那么当前字符这个t[j - 1]可能就是我们需要删去的字符，是否为子序列就需要看s[i - 1]和t[j - 2]的匹配结果，即<code>dp[i][j - 1]</code></p><ol start="3"><li>如何初始化dp数组</li></ol><p>下标0表示为空串，因此<code>dp[0][j]</code>是true，<code>dp[i][0]</code>除了<code>dp[0][0]</code>其它都为false</p><ol start="4"><li>如何遍历 &#x3D;&gt; 从小到大</li><li>推导例子</li></ol><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>这道题也可以去记录匹配到的子串的长度，最后判断其是否和s字符串的长度相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="[115] 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/description/">[115] 不同的子序列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Hard-red.svg" alt="LeetCode Hard" style="text-align: left;"></div><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 109 + 7 取模。</p><h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><ol><li>dp数组的含义</li></ol><p><strong>求什么就定义什么，因为求s中有多少个t，因此<code>dp[i][j]</code>就表示s[i - 1]中t[j - 1]的个数</strong></p><ol start="2"><li>状态转移方程</li></ol><p>（1）如果当前s[i - 1]和t[j - 1]相等，那么我们就要看<code>dp[i - 1][j - 1]</code>的大小，比如beag和bag依赖于bea和ba中的个数，因为后者为1所以递推前者也为1。但是这是最简单的情况，因为我们可以选择不用s[i - 1]来匹配。</p><p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><p>如果不选择用s[i - 1]来匹配即等于删去此字符的操作，个数就取决于s[i - 2]匹配t[j - 1]的情况，即<code>dp[i - 1][j]</code>。</p><p>所以即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">  dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure><p>（2）如果不等的话就单纯只有<code>dp[i - 1][j]</code></p><ol start="3"><li>初始化问题</li></ol><p><code>dp[i][0]</code>表示s里以s[i - 1]为结尾的子串中空串的个数，都为1</p><p><code>dp[0][j]</code>表示空串里出现的t[j - 1]的个数，为0</p><p>其中具体问题具体分析<code>dp[0][0]</code>应该是0。</p><ol start="4"><li>遍历，从小到大遍历</li><li>例子推导</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        dp[i][j] = dp[i][j] % ((<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="[583] 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">[583] 两个字符串的删除操作</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为<code>dp[i - 1][j]</code> + 1 </p><p>情况二：删word2[j - 1]，最少操作次数为<code>dp[i][j - 1]</code> + 1 </p><p><del>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为<code>dp[i - 1][j - 1]</code> + 2</del></p><blockquote><p>如果不相等的情况为什么不考虑同时删除两个不相等元素即<code>dp[i][j] = dp[i - 1][j - 1] + 2</code>的情况，因为<code>dp[i][j - 1]</code>的值是由<code>dp[i - 1][j - 1] + 1</code>和<code>dp[i][j - 2] + 1</code>以及<code>dp[i - 1][j - 2] + 2</code>得来的，而且是取得最优情况，所以<code>dp[i][j - 1] &lt;= dp[i - 1][j - 1]</code>，所以没必要再在<code>dp[i][j]</code>中画蛇添足加一个已经被包含了的情况进去了。</p></blockquote><p>所以递推公式可简化为：<code>dp[i][j]</code> &#x3D; min(<code>dp[i - 1][j]</code> + 1, <code>dp[i][j - 1]</code> + 1);</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word<span class="number">1.</span><span class="built_in">size</span>(), m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)  dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="[72] 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/description/">[72] 编辑距离</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><blockquote><p>来自leetcode评论区的神仙解析</p><p>这题如果不是编辑距离模板题感觉根本就是hard</p></blockquote><p>（1）当word1[i] &#x3D;&#x3D; word2[j]时，由于遍历到了i和j,说明word1的0到i-1和word2的0到j-1的匹配结果已经生成，由于当前两个字符相同，因此无需做任何操作，<code>dp[i][j] = dp[i - 1][j - 1]</code><br>（2）当word1[i] !&#x3D; word2[j]时,可以进行的操作有3个:<br>      ① 替换操作：可能word1的0到i-1位置与word2的0到j-1位置的字符都相同，只是当前位置的字符不匹配，进行替换操作后两者变得相同，所以此时<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>（这个加1代表执行替换操作）<br>      ② 删除操作：若此时word1的0到i-1位置与word2的0到j位置已经匹配了，此时多出了word1的i位置字符，应把它删除掉，才能使此时word1的0到i（这个i是执行了删除操作后新的i）和word2的0到j位置匹配，因此此时<code>dp[i][j] = dp[i - 1][j] + 1</code>（这个加1代表执行删除操作）<br>      ③ 插入操作：若此时word1的0到i位置只是和word2的0到j-1位置匹配，此时只需要在原来的i位置后面插入一个和word2的j位置相同的字符使得此时的word1的0到i（这个i是执行了插入操作后新的i）和word2的0到j匹配得上，所以此时<code>dp[i][j] = dp[i][j - 1] + 1</code>（这个加1代表执行插入操作）<br>      ④ 由于题目所要求的是要最少的操作数：所以当word1[i] !&#x3D; word2[j] 时，需要在这三个操作中选取一个最小的值赋格当前的<code>dp[i][j]</code></p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word<span class="number">1.</span><span class="built_in">size</span>(), m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)  dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="[712] 两个字符串的最小ASCII删除和"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/?envType=study-plan-v2&envId=dynamic-programming">[712] 两个字符串的最小ASCII删除和</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 <em>使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</em> 。</p><h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><blockquote><p>难得AC如此之快，编辑距离双向删减版套皮</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dp[i][j]数组的含义：字符串s1[<span class="number">0</span>: i]和字符串s2[<span class="number">0</span>: j]相等需要删除的最小和</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 状态转移方程</span><br><span class="line">s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]:  dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">s1[i - <span class="number">1</span>] != s2[j - <span class="number">1</span>]:  dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + (<span class="type">int</span>)s2[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + (<span class="type">int</span>)s1[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 初始化:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  dp[i][<span class="number">0</span>] += dp[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="type">int</span>)s1[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">  dp[<span class="number">0</span>][i] += dp[<span class="number">0</span>][i - <span class="number">1</span>] + (<span class="type">int</span>)s2[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s<span class="number">1.</span><span class="built_in">size</span>(), m = s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      dp[i][<span class="number">0</span>] += dp[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="type">int</span>)s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">      dp[<span class="number">0</span>][i] += dp[<span class="number">0</span>][i - <span class="number">1</span>] + (<span class="type">int</span>)s2[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j- <span class="number">1</span>]) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + (<span class="type">int</span>)s2[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + (<span class="type">int</span>)s1[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h1><blockquote><p>总结一下：</p><ul><li>回文子串得定义成vector<code>&lt;vector&lt;bool&gt;&gt;</code>类型，另外求长度</li><li>回文子序列得定义成<code>vector&lt;vector&lt;int&gt;&gt;</code>，递推求长度</li></ul></blockquote><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="[647] 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/description/">[647] 回文子串</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><ol><li>dp数组含义</li></ol><p>因为要统计回文的个数，所以我们需要开dp数组判断当前是否是回文，如果是的话，计数器cnt++。</p><p>回文字符串的判断老生常谈</p><ol start="2"><li>状态转移方程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化 &#x3D;&gt; 如果j从i开始遍历就无需初始化，开dp数组的时候全false即可</li><li>遍历顺序</li></ol><p>i依赖于i+1，j依赖于j-1，从左下角开始遍历，j要大于i</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]))</span><br><span class="line">          cnt++, dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="[516] 最长回文子序列"></a><a href>[516] 最长回文子序列</a></h2><div style="display: flex;">  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow.svg" alt="LeetCode Medium" style="text-align: left;"></div><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><ol><li><code>dp[i][j]</code>代表s[i: j]回文子序列长度</li><li>状态转移方程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">  dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;<span class="comment">// 首尾加入</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);<span class="comment">// 试探一下单个加入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化 &#x3D;&gt; <code>dp[i][i] = 1</code></li><li>遍历顺序 &#x3D;&gt; 左下角</li></ol><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">          dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://elubrazione.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2023年末总结</title>
    <link href="https://elubrazione.github.io/2023/12/31/essay-3/"/>
    <id>https://elubrazione.github.io/2023/12/31/essay-3/</id>
    <published>2023-12-31T15:59:59.000Z</published>
    <updated>2024-04-03T07:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>始于2023年的新坑</p><span id="more"></span><h2 id="简短的总结"><a href="#简短的总结" class="headerlink" title="简短的总结"></a>简短的总结</h2><blockquote><p>Shoot for the moon, even if you fail, you will land among the stars.</p></blockquote><p>年底和考完研的舍友一起去了青岛，回来之后感觉好疲惫，认为自己还是适合窝在屋子里做点事情。</p><p>年底复盘的时候发现自己今年做的事情没有想象中那么多，可能只是因为到了大三大四这个时间点所以“理所当然”发生了许多自己看起来很重要的事情，今年取得的成就很多也是前两年耕耘出来的。所以希望新的一年自己能够过得更充实一点吧。</p><h2 id="一个新年愿望清单"><a href="#一个新年愿望清单" class="headerlink" title="一个新年愿望清单"></a>一个新年愿望清单</h2><ul><li><input checked disabled type="checkbox"> <del>上岸北京大学</del></li><li><input disabled type="checkbox"> 保持刷算法题的习惯 : ) 不刷题是找不到好工作的亲爱的</li><li><input disabled type="checkbox"> 完成毕业设计，拿到本科优秀毕设</li><li><input disabled type="checkbox"> 本科毕业到研究生入学期间找到一份实习并有所<strong>成长与收获</strong></li><li><input disabled type="checkbox"> 英语综合能力再上一个台阶，重新考个托福</li><li><input disabled type="checkbox"> 完成飞跃手册初版发布</li><li><input disabled type="checkbox"> The Power of Now 运营</li><li><input disabled type="checkbox"> 好好记录生活</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;始于2023年的新坑&lt;/p&gt;</summary>
    
    
    
    <category term="年末总结" scheme="https://elubrazione.github.io/categories/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://elubrazione.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HUST系统能力培养之虚拟机</title>
    <link href="https://elubrazione.github.io/2023/12/17/pa-virtual-machine/"/>
    <id>https://elubrazione.github.io/2023/12/17/pa-virtual-machine/</id>
    <published>2023-12-17T10:40:58.000Z</published>
    <updated>2024-01-16T08:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>系统能力培养虚拟机实验教程</p><span id="more"></span><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这是一个速通教程，高尚的人请你立刻叉出去。</p><p>抄也要花一些时间，建议抄的同时弄懂，所以尽早开始。</p><h1 id="pa0"><a href="#pa0" class="headerlink" title="pa0"></a>pa0</h1><blockquote><p>VirtualBox安装包和老师给的前置打包环境root.vdi文件请自行在课程官网获取，创建并导入后无需安装任务书中所写的pa0环境依赖。</p><p><strong>本章内容：</strong>在你的电脑本机使用ssh免密丝滑连接你的虚拟机，此方法可推广至服务器连接。如果你想直接在虚拟机里下载Vscode写代码可以跳过此章。</p></blockquote><h2 id="虚拟机网络配置"><a href="#虚拟机网络配置" class="headerlink" title="虚拟机网络配置"></a>虚拟机网络配置</h2><p>给你的虚拟机新增一块网卡，启用网络连接、连接方式选择仅主机。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219013901608.png" alt="image-20231219013901608"></p><p>添加后重新启动虚拟机并打开终端，依赖安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install net-tools</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>获取信息如下：<code>enp0s8</code>后第二行的inet <mark>192.168.56.101</mark>，记住它尤其是前缀。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219012358447.png" alt="image-20231219012358447"></p><p>打开你的本机windows，<code>设置</code> -&gt; <code>网络和Internet</code> -&gt; <code>高级网络设置</code></p><p>找到virtualBox，并选择 <code>查看其他属性</code>，观察你的IPv4地址的前四位和上面在虚拟机里看到的前24位是否相同，不同的话手动改一下本机的。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219014226124.png" alt="image-20231219014226124"></p><p>相同后ping一下试试，一般没问题，有问题我也不知道为什么。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219014504625.png" alt="image-20231219014504625"></p><p>回到你的虚拟机，继续配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install openssh-server</span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/ssh start</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.backup <span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>追加以下内容，注意倒三行是写上你的用户名，不过按理来说大家应该都叫<code>hust</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">AddressFamily any</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line">ListenAddress ::</span><br><span class="line">UsePrivilegeSeparation no</span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">AllowUsers hust</span><br><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubKeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>大概长这样</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219005718404.png" alt="image-20231219005718404"></p><p>写完保存退出后重启一下ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh --full-restart</span><br></pre></td></tr></table></figure><p>回到你的windows终端里测试一下连接 <code>ssh -p 22 hust@your ip</code>，如下表示成功：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231219005910190.png" alt="image-20231219005910190"></p><h2 id="免密登录配置"><a href="#免密登录配置" class="headerlink" title="免密登录配置"></a>免密登录配置</h2><blockquote><p><del>让我用vim写代码，不可能的事情</del></p></blockquote><p>重复的东西不想写了，请参考我的<a href="https://elubrazione.github.io/2021/03/30/virtual-env-install/#/VsCode%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA">另一篇配置Vmware的博客</a>的<code>VsCode免密连接虚拟机</code>一章</p><h1 id="pa1"><a href="#pa1" class="headerlink" title="pa1"></a>pa1</h1><blockquote><p>完成这个课设的关键是：认真阅读手册和代码</p><p>cd到 <code>./nemu</code> 文件夹下，修改Makefile文件，ISA改成riscv32。</p><p>因为pa1比较简单，新手保护期课程手册给的很详细、代码也不复杂很容易就能看懂。</p><p>速通秘诀：所有要修改的文件如下，自己抄答案对着复制（详细内容等我写完报告回来更新）</p></blockquote><h2 id="pa-1-1"><a href="#pa-1-1" class="headerlink" title="pa-1.1"></a>pa-1.1</h2><p><img src="/2023/12/17/pa-virtual-machine/image-20240110024944765.png" alt="image-20240110024944765"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240110025835972.png" alt="image-20240110025835972"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240110025906493.png" alt="image-20240110025906493"></p><h2 id="结果提交"><a href="#结果提交" class="headerlink" title="结果提交"></a>结果提交</h2><p><img src="/2023/12/17/pa-virtual-machine/image-20231225201012675.png" alt="image-20231225201012675"></p><p>修改完后使用 <code>make submit</code> 提交，输入初始化的账号密码。如下，提交成功。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20231225201405072.png" alt="image-20231225201405072"></p><h1 id="pa2"><a href="#pa2" class="headerlink" title="pa2"></a>pa2</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><blockquote><p>要改的文件见本章最后“提交结果”，以下是实验过程记录。</p></blockquote><p>按照GitBook教程创建新的分支；</p><p>下载好交叉编译器到本地（注意版本），传到虚拟机里，注意路径。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102152841211.png" alt="image-20240102152841211"></p><p>传完了之后解压，然后按照教程更改环境变量，改完记得要<strong>先激活一下</strong>，出现如下情况说明成功。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102153216666.png" alt="image-20240102153216666"></p><h2 id="pa-2-1"><a href="#pa-2-1" class="headerlink" title="pa-2.1"></a>pa-2.1</h2><p>这部分要求实现dummy.c程序的运行，运行起来后是 <mark>ABORT</mark> 的状态</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102154028356.png" alt="image-20240102154028356"></p><p>通过make生成的 <code>nexus-am/tests/cputest/build/dummy-riscv32-nemu.txt</code> 文件找到看起来需要实现的指令有： li、auipc、addi、jal、lui、mv、sw、ret。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102154808201.png" alt="image-20240102154808201"></p><p>通过手册我们可以发现 <code>li</code> 指令是<code>lui</code> 和 <code>addi</code> 指令的组合，因此不需要单独实现；最后的 <code>ret</code> 指令是伪指令，其实需要实现的是 <code>jalr</code>；<code>mv</code> 指令也是伪指令，会被扩展成 <code>addi rd, rs1, 0</code>，不需要单独实现。通过阅读代码发现 <code>sw</code> 也已经实现（st和store，st执行辅助函数在 <code>ldst.c</code>文件）</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102172203578.png" alt="image-20240102172203578"></p><blockquote><p><strong>实现新指令的方法</strong></p><ol><li>在<code>opcode_table</code>中填写正确的译码辅助函数, 执行辅助函数以及操作数宽度；</li><li>用RTL实现正确的执行辅助函数, 需要注意使用RTL伪指令时要遵守上文提到的小型调用约定</li></ol></blockquote><h3 id="lui"><a href="#lui" class="headerlink" title="lui"></a>lui</h3><p>属于U型指令，opcode_table写入 <code>nemu/src/isa/riscv32/exec/exec.c</code>、译码辅助函数 <code>nemu/src/isa/riscv32/decode.c</code> 、执行辅助函数 <code>nemu/src/isa/riscv32/exec/compute.c</code> 都已经帮我们实现了。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102173017738.png" alt="image-20240102173017738"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102173457143.png" alt="image-20240102173457143"></p><p>这里填13是因为 <code>lui</code> 指令的操作码是0110111，第6到2位是01101，即十进制的13，所以对应opcode_table[13]。注释里的00&#x2F;01&#x2F;10&#x2F;11是指它的操作码的第七位和第六位，先根据这个索引再往后看三位，所以一行有八个空。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102180028847.png" alt="image-20240102180028847"></p><h3 id="auipc"><a href="#auipc" class="headerlink" title="auipc"></a>auipc</h3><p>属于U型指令，译码辅助函数上面lui已经实现，这里只需要实现执行辅助函数即可和填表即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(auipc) &#123;</span><br><span class="line">  rtl_add(&amp;id_dest-&gt;val, &amp;cpu.pc, &amp;id_src-&gt;val);</span><br><span class="line">  rtl_sr(id_dest-&gt;reg, &amp;id_dest-&gt;val, <span class="number">4</span>);</span><br><span class="line">  print_asm_template2(auipc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/17/pa-virtual-machine/image-20240102174032127.png" alt="image-20240102174032127"></p><p>第五位填表</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102175148979.png" alt="image-20240102175148979"></p><h3 id="addi"><a href="#addi" class="headerlink" title="addi"></a>addi</h3><p>属于I型指令，要实现一个I型译码辅助函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(I) &#123;</span><br><span class="line">  decode_op_r(id_src, decinfo.isa.instr.rs1, <span class="literal">true</span>);</span><br><span class="line">  decode_op_i(id_src2, decinfo.isa.instr.simm11_0, <span class="literal">true</span>);</span><br><span class="line">  decode_op_r(id_dest, decinfo.isa.instr.rd, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现一个执行辅助函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(addi) &#123;</span><br><span class="line">  rtl_add(&amp;id_dest-&gt;val, &amp;id_src-&gt;val, &amp;id_src2-&gt;val);</span><br><span class="line">  rtl_sr(id_dest-&gt;reg, &amp;id_dest-&gt;val, <span class="number">4</span>);</span><br><span class="line">  print_asm_template3(addi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四位填表。</p><p>后面的 <code>jalr</code>、<code>jal</code>流程也差不多。</p><p>填完的表是这样的：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102192107533.png" alt="image-20240102192107533"></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这里遇到了一个bug：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102193301193.png" alt="image-20240102193301193"></p><p>根据错误信息“riscv-none-embed-ld: Command not found”得到信息应该是构建过程中找不到 <code>riscv-none-embed-ld</code> 命令，所以是环境变量的问题，重新激活一下环境变量即可。</p><p>重新make run，显示成功：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102193058260.png" alt="image-20240102193058260"></p><h2 id="pa-2-2"><a href="#pa-2-2" class="headerlink" title="pa-2.2"></a>pa-2.2</h2><blockquote><p>上面pa2-1对应的那几个文件现在除了 <code>system</code> 系统调用指令其它都可以复制了。</p></blockquote><p>这部分要求完善AM项目下的代码，实现更多的指令和一些必要的库函数。</p><p>使用 <code>runall.sh</code> 脚本测试一下，会在本地反汇编出所有没有通过的测试文件。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103094841583.png" alt="image-20240103094841583"></p><p>同时会给出测试结果</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240102211231467.png" alt="image-20240102211231467"></p><h3 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h3><p>要实现好多I型指令，不妨尝试抽象成整个I型执行辅助函数，避免代码的重复，使用switch函数先对 <code>decinfo.isa.instr.funct3</code> 的值进行分支跳转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (decinfo.isa.instr.funct3) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// addi相关</span></span><br><span class="line">      rtl_addi(&amp;id_dest-&gt;val, &amp;id_src-&gt;val, decinfo.isa.instr.simm11_0);</span><br><span class="line">      <span class="keyword">if</span> (decinfo.isa.instr.rs1 == <span class="number">0</span>) &#123; <span class="comment">// li伪指令</span></span><br><span class="line">        print_asm_template2(li);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decinfo.isa.instr.simm11_0 == <span class="number">0</span>) &#123; <span class="comment">// mv伪指令</span></span><br><span class="line">        print_asm_template2(mv);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// addi本身</span></span><br><span class="line">        print_asm_template3(addi);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      assert(<span class="number">0</span> &amp;&amp; <span class="string">&quot;Unfind the opcode&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再在此基础上进行完善，此过程就是不断的查表和调试。</p><p>然后更改opcode_table对应的字段，其实就是把原来的addi改成i即可。</p><h3 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h3><p>同理，实现译码辅助函数和执行辅助函数然后填表，不再赘述。</p><p>注意mulhsu指令实现的时候要自己封装一个rtl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./nemu/include/rtl/c_op.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c_mul_hsu(a, b) (((int64_t)(a) * (uint64_t)(b)) &gt;&gt; 32) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./nemu/include/rtl/rtl-wrapper.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rtl_mul_hsu   concat(RTL_PREFIX, _rtl_mul_hsu )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./nemu/include/rtl/rtl.h</span></span><br><span class="line">make_rtl_arith_logic(mul_hsu)</span><br></pre></td></tr></table></figure><h3 id="B型指令"><a href="#B型指令" class="headerlink" title="B型指令"></a>B型指令</h3><p>在control.c添加执行辅助函数，老地方添加译码辅助函数，然后填表。</p><p>到这一步测试一下，结果是这样的。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103101942561.png" alt="image-20240103101942561"></p><h3 id="Load和Store指令"><a href="#Load和Store指令" class="headerlink" title="Load和Store指令"></a>Load和Store指令</h3><p>这部分需要在 <code>ldst.c</code> 文件里完成执行辅助函数，填充load_table,store_table。</p><p>store指令的执行函数已经实现了没什么问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> OpcodeEntry load_table [<span class="number">8</span>] = &#123;</span><br><span class="line">  EXW(ld, <span class="number">1</span>), EXW(ld, <span class="number">2</span>), EXW(ld, <span class="number">4</span>), EMPTY, EXW(ld, <span class="number">1</span>), EXW(ld, <span class="number">2</span>), EMPTY, EMPTY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> OpcodeEntry store_table [<span class="number">8</span>] = &#123;</span><br><span class="line">  EXW(st, <span class="number">1</span>), EXW(st, <span class="number">2</span>), EXW(st, <span class="number">4</span>), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这部分完成后测试发现load-store文件和string文件无法通过，查看教程发现string.c需要实现 <code>nexus-am/libs/klib/src/string</code>. 而根据load-store-log.txt出错的原因如下，即没有找到rtl_sext，所以我们需要补充一下。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103111453042.png" alt="image-20240103111453042"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rtl_sext</span><span class="params">(<span class="type">rtlreg_t</span>* dest, <span class="type">const</span> <span class="type">rtlreg_t</span>* src1, <span class="type">int</span> width)</span> &#123;</span><br><span class="line">  <span class="type">int32_t</span> temp = *src1;</span><br><span class="line">  <span class="keyword">switch</span>(width) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: *dest = *src1; <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: temp = temp &lt;&lt;  <span class="number">8</span>; *dest = temp &gt;&gt;  <span class="number">8</span>; <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: temp = temp &lt;&lt; <span class="number">16</span>; *dest = temp &gt;&gt; <span class="number">16</span>; <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: temp = temp &lt;&lt; <span class="number">24</span>; *dest = temp &gt;&gt; <span class="number">24</span>; <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：成功</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103112221893.png" alt="image-20240103112221893"></p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>各个函数功能和实现思路下：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="center">实现思路</th></tr></thead><tbody><tr><td align="center"><code>strlen</code></td><td align="center">计算字符串的长度</td><td align="center">遍历字符串，直到遇到字符串结束符，记录遍历的次数作为字符串的长度。</td></tr><tr><td align="center"><code>strcpy</code></td><td align="center">将源字符串复制到目标字符串</td><td align="center">遍历源字符串的每个字符，逐个将字符复制到目标字符串中，直到遇到源字符串的结束符。最后，在目标字符串的末尾添加结束符。</td></tr><tr><td align="center"><code>strncpy</code></td><td align="center">将源字符串的一部分复制到目标字符串</td><td align="center">遍历源字符串的每个字符，在达到指定的复制长度 <code>n</code> 或者遇到源字符串的结束符之前，将字符复制到目标字符串中。如果已经复制了 <code>n</code> 个字符，但源字符串仍未结束，则在目标字符串的末尾添加结束符。</td></tr><tr><td align="center"><code>strcat</code></td><td align="center">将源字符串追加到目标字符串的末尾</td><td align="center">首先找到目标字符串的结束符，然后遍历源字符串的每个字符，将字符追加到目标字符串的末尾，并在最后添加结束符。</td></tr><tr><td align="center"><code>strcmp</code></td><td align="center">比较两个字符串的大小</td><td align="center">逐个比较两个字符串中的字符，直到遇到不相等的字符或者其中一个字符串结束。</td></tr><tr><td align="center"><code>strncmp</code></td><td align="center">比较两个字符串的大小，最多比较 <code>n</code> 个字符</td><td align="center">与 <code>strcmp</code> 函数类似，但是限制了最大比较的字符数量为 <code>n</code></td></tr><tr><td align="center"><code>memset</code></td><td align="center">将一块内存区域填充为指定的值</td><td align="center">将内存区域的每个字节都设置为指定的值 <code>c</code>，实现了内存的填充操作。</td></tr><tr><td align="center"><code>memcpy</code></td><td align="center">将一块内存区域复制到另一块内存区域</td><td align="center">遍历源内存区域的每个字节，逐个将字节复制到目标内存区域中，实现了内存的复制操作。</td></tr><tr><td align="center"><code>memcmp</code></td><td align="center">比较两块内存区域的内容是否相等</td><td align="center">逐个比较两个内存区域中的字节，直到遇到不相等的字节或者比较的次数达到指定的长度 <code>n</code>。</td></tr></tbody></table><p>string.c通过了之后hello-str.c又不能通过了….看教程是要完成 <code>sprintf()</code> 函数，它的参数数目是可变的。</p><p>为了实现这个函数我们要根据格式字符串 <code>fmt</code> 和可变参数列表中的参数，将格式化后的字符串存储在目标字符串 <code>out</code> 中。然后调用 <code>vsprintf</code> 函数将格式化的字符串存储在目标字符串中，返回格式化后的字符串长度 <code>len</code>。</p><p>一共需要下列几个辅助函数：</p><ol><li><code>vsprintf</code> 函数：根据格式字符串 <code>fmt</code> 和可变参数列表中的参数，将格式化后的字符串存储在目标字符串 <code>out</code> 中。通过遍历格式字符串的每个字符，根据不同的格式符进行相应的处理。当遇到普通字符时，将其直接复制到目标字符串中；当遇到格式符 <code>%</code> 时，根据后续字符来解析相应的参数，并调用相应的函数进行处理。函数返回格式化后的字符串长度 <code>out_len</code>。</li><li><code>add_string</code> 函数：将字符串添加到目标字符串中。</li><li><code>add_char</code> 函数：将字符添加到目标字符串中。</li><li><code>is_digit</code> 函数：判断一个字符是否为数字；</li><li><code>add_number</code> 函数：将数字添加到目标字符串中。</li></ol><p>完成这部分之后就能通过全部的测试文件。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103150857113.png" alt="image-20240103150857113"></p><h2 id="pa-2-3"><a href="#pa-2-3" class="headerlink" title="pa-2.3"></a>pa-2.3</h2><h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><h4 id="运行Hello-World"><a href="#运行Hello-World" class="headerlink" title="运行Hello World"></a>运行Hello World</h4><p>修改文件，打开HAS_IOE宏定义，关闭调试。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103152240263.png" alt="image-20240103152240263"></p><p>运行结果</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103154056515.png" alt="image-20240103154056515"></p><h4 id="实现printf"><a href="#实现printf" class="headerlink" title="实现printf"></a>实现printf</h4><p>根据之前实现 <code>sprintf()</code> 的思路，调用 <code>vsprintf()</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  <span class="type">char</span> outBuf[<span class="number">256</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">int</span> length = <span class="built_in">vsprintf</span>(outBuf, fmt, args); </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; outBuf[i]; i++) &#123;</span><br><span class="line">    _putc(outBuf[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(args);</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>先在初始化函数 <code>__am_timer_init</code> 中对 <code>boot_time</code> 进行初始化， 然后在 <code>_DEVREG_TIMER_UPTIME</code> 条件分支下将 <code>uptime-&gt;lo</code> 更新为当前时间和初始时间的差。</p><p>测试一下，显示成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mainargs=t run</span><br></pre></td></tr></table></figure><p><img src="/2023/12/17/pa-virtual-machine/image-20240103170944921.png" alt="image-20240103170944921"></p><h4 id="跑分结果"><a href="#跑分结果" class="headerlink" title="跑分结果"></a>跑分结果</h4><h5 id="coremark"><a href="#coremark" class="headerlink" title="coremark"></a>coremark</h5><p><img src="/2023/12/17/pa-virtual-machine/image-20240103193835049.png" alt="image-20240103193835049"></p><h5 id="dhrystone"><a href="#dhrystone" class="headerlink" title="dhrystone"></a>dhrystone</h5><p><img src="/2023/12/17/pa-virtual-machine/image-20240103193917212.png" alt="image-20240103193917212"></p><h5 id="microbench"><a href="#microbench" class="headerlink" title="microbench"></a>microbench</h5><p><img src="/2023/12/17/pa-virtual-machine/image-20240103194108336.png" alt="image-20240103194108336"></p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>先通过 <code>inl(KBD_ADDR)</code> 从 MMIO 中获取键盘码，通过键盘码和<code>KEYDOWN_MASK</code> 相与得到当前键盘的状态， 通过键盘码和 <code>～KEYDOWN_MASK</code> 相与得到没有按键时的状态。代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> keyboard_code = inl(KBD_ADDR);</span><br><span class="line">kbd-&gt;keydown = keyboard_code &amp; KEYDOWN_MASK ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">kbd-&gt;keycode = keyboard_code &amp; ~KEYDOWN_MASK;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(_DEV_INPUT_KBD_t);</span><br></pre></td></tr></table></figure><p>这里要回虚拟机进行测试，因为在Vscode里没法进行弹窗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ics2019/nexus-am/tests/amtest/</span><br><span class="line">make ARCH=riscv32-nemu mainargs=k run</span><br></pre></td></tr></table></figure><p><img src="/2023/12/17/pa-virtual-machine/image-20240103201730935.png" alt="image-20240103201730935"></p><h3 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h3><p>这里有两个工作：</p><ol><li>完善 <code>nemu/src/device/vga.c</code> 中的 <code>vga_io_handler()</code> 函数；</li><li>实现 <code>_DEVREG_VIDEO_INFO</code> 和 <code>_DEVREG_VIDEO_FBCTL</code> 的功能。</li></ol><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=riscv32-nemu mainargs=v run</span><br></pre></td></tr></table></figure><p><img src="/2023/12/17/pa-virtual-machine/image-20240103203649913.png" alt="image-20240103203649913"></p><h3 id="其它结果展示"><a href="#其它结果展示" class="headerlink" title="其它结果展示"></a>其它结果展示</h3><h4 id="slider"><a href="#slider" class="headerlink" title="slider"></a>slider</h4><p><img src="/2023/12/17/pa-virtual-machine/image-20240103210243102.png" alt="image-20240103210243102"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103210415000.png" alt="image-20240103210415000"></p><h4 id="typing"><a href="#typing" class="headerlink" title="typing"></a>typing</h4><p><img src="/2023/12/17/pa-virtual-machine/image-20240103210605118.png" alt="image-20240103210605118"></p><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="/2023/12/17/pa-virtual-machine/image-20240103210841567.png" alt="image-20240103210841567"></p><p>merge到master</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240103211049445.png" alt="image-20240103211049445"></p><h1 id="pa3"><a href="#pa3" class="headerlink" title="pa3"></a>pa3</h1><h2 id="pa-3-1"><a href="#pa-3-1" class="headerlink" title="pa-3.1"></a>pa-3.1</h2><h3 id="实现自陷操作"><a href="#实现自陷操作" class="headerlink" title="实现自陷操作"></a>实现自陷操作</h3><p>在<code>nanos-lite/include/common.h</code>中定义 <code>HAS_CTE</code>。</p><p>定义了宏<code>HAS_CTE</code>后, Nanos-lite会在<code>panic()</code>前调用<code>_yield()</code>来触发自陷操作. 为了支撑这次自陷操作, 需要在NEMU中实现<code>raise_intr()</code>函数来模拟异常响应机制。</p><p>修改 <code>ISADecodeInfo</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> &#123;</span></span><br><span class="line">  Instr instr;</span><br><span class="line">  <span class="type">uint32_t</span> sepc;</span><br><span class="line">  <span class="type">uint32_t</span> sstatus;</span><br><span class="line">  <span class="type">uint32_t</span> scause;</span><br><span class="line">  <span class="type">uint32_t</span> stvec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终实现的 <code>raise_intr()</code> 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_intr</span><span class="params">(<span class="type">uint32_t</span> NO, <span class="type">vaddr_t</span> epc)</span> &#123;</span><br><span class="line">  decinfo.isa.sepc = epc;</span><br><span class="line">  decinfo.isa.scause = NO;</span><br><span class="line">  decinfo.jmp_pc = decinfo.isa.stvec;</span><br><span class="line">  rtl_j(decinfo.jmp_pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要实现ecall环境调用指令、sret 管理员模式例外返指令，及一系列的控制状态寄存器相关操作的指令。</p><p>步骤同pa2一样逐步完成译码辅助函数、执行辅助函数的编写和对应的声明，最后在opcode_table填表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译码辅助函数</span></span><br><span class="line">make_DHelper(SYSTEM) &#123;</span><br><span class="line">  decode_op_r(id_src, decinfo.isa.instr.rs1, <span class="literal">true</span>);</span><br><span class="line">  decode_op_i(id_src2, decinfo.isa.instr.csr, <span class="literal">true</span>);</span><br><span class="line">  decode_op_r(id_dest, decinfo.isa.instr.rd, <span class="literal">false</span>);</span><br><span class="line">  print_Dop(id_src-&gt;str, OP_STR_SIZE, <span class="string">&quot;0x%x&quot;</span>, decinfo.isa.instr.csr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行辅助函数的部分我们需要两个控制状态寄存器相关指令，一个负责读取一个负责写入。写入时接受一个CSR编号和一个要写入的值作为参数，根据CSR编号将给定的值写入相应的CSR；读取则只需要一个CSR编号作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_csr</span><span class="params">(<span class="type">int</span> csr, <span class="type">int32_t</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(csr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x100</span>:decinfo.isa.sstatus = val; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x105</span>:decinfo.isa.stvec = val; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x141</span>: decinfo.isa.sepc = val; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x142</span>: decinfo.isa.scause = val; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(!<span class="string">&quot;Unfind the csr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">read_csr</span><span class="params">(<span class="type">int</span> csr)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span>(csr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x100</span>: <span class="keyword">return</span> decinfo.isa.sstatus;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x105</span>: <span class="keyword">return</span> decinfo.isa.stvec;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x141</span>: <span class="keyword">return</span> decinfo.isa.sepc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x142</span>: <span class="keyword">return</span> decinfo.isa.scause;</span><br><span class="line">    <span class="keyword">default</span>: assert(!<span class="string">&quot;Unfind the csr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用上述两个寄存器控制指令和前面完成的 <code>raise_intr()</code> 函数来完成触发异常后的响应，完成执行辅助函数。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240104132130382.png" alt="image-20240104132130382"></p><p>成功跳转：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240104143223004.png" alt="image-20240104143223004"></p><h3 id="保存上下文"><a href="#保存上下文" class="headerlink" title="保存上下文"></a>保存上下文</h3><p>顺序是gpr, cause, status, epc, as</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240105153308810.png" alt="image-20240105153308810"></p><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>这一部分需要我们先在 <code>__am_irq_handle()</code> 函数中通过异常号识别出自陷异常, 然后将event 设置为编号为 <code>_EVENT_YIELD</code> 的自陷事件；然后通过<code>do_event()</code>函数根据事件类型再次进行分发。<mark>注意这里不要全复制了，只复制 <code>case _EVENT_YIELD</code> 和 <code>case -1</code> 部分，其它是pa3-2的。</mark></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240104185658130.png" alt="image-20240104185658130"></p><p>实现成功，可以看到在下图中成功打印了我们的提示语句“Self trap!”。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240104192458814.png" alt="image-20240104192458814"></p><h3 id="恢复上下文"><a href="#恢复上下文" class="headerlink" title="恢复上下文"></a>恢复上下文</h3><p>这部分需要实现sret指令即可，前面已经实现了。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240104192553664.png" alt="image-20240104192553664"></p><h2 id="pa-3-2"><a href="#pa-3-2" class="headerlink" title="pa-3.2"></a>pa-3.2</h2><h3 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h3><p>在这里先补充 <code>./nanos-lite/src/loader.c</code> 中的loader函数，实现用户程序加载。</p><p><code>resource.S</code>文件里用汇编将<code>ramdisk.img</code>放在了静态存储区data section（实际上程序应该放在硬盘中，但就如文档所说当前用ram来模拟，因此放在了内存中的静态存储区），我们需要负责判断elf合法性，如果合法的话，我们需要做的是把程序加载到它应该处于的内存段中，以及将.bss段（全局变量区）清零，其中phdr（program header）中的<code>p_vaddr</code>即程序段应该加载到的内存段的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  Elf_Ehdr ehdr;</span><br><span class="line">  ramdisk_read(&amp;ehdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  assert((*(<span class="type">uint32_t</span> *)ehdr.e_ident == <span class="number">0x464c457f</span>));</span><br><span class="line"></span><br><span class="line">  Elf_Phdr phdr[ehdr.e_phnum];</span><br><span class="line">  ramdisk_read(phdr, ehdr.e_phoff, <span class="keyword">sizeof</span>(Elf_Phdr)*ehdr.e_phnum);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_phnum; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phdr[i].p_type == PT_LOAD) &#123;</span><br><span class="line">      ramdisk_read((<span class="type">void</span>*)phdr[i].p_vaddr, phdr[i].p_offset, phdr[i].p_memsz);</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)(phdr[i].p_vaddr+phdr[i].p_filesz), <span class="number">0</span>, phdr[i].p_memsz - phdr[i].p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ehdr.e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>proc.c</code> 中添加教程要求的 <code>naive_uload(NULL, NULL)</code>，调用刚刚实现的loader来加载第一个用户程序，可以看到执行<code>dummy</code>程序时在Nanos-lite中触发了一个未处理的1号事件。同时我们可以看到绿色框上面显示调用了 <code>naive_uload</code> 的信息。</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240105152409549.png" alt="image-20240105152409549"></p><h3 id="识别系统调用"><a href="#识别系统调用" class="headerlink" title="识别系统调用"></a>识别系统调用</h3><p>观察<code>_syscall_</code>的代码，发现是从<code>a0</code>寄存器取得系统调用的返回结果，因此修改<code>GPRx</code>的宏定义，将其改成寄存器<code>a0</code>的下标，就可以在操作系统中通过<code>c-&gt;GPRx</code>根据实际情况设置返回值了</p><p>然后要在 <code>syscall.c</code> 文件中实现 <code>do_event()</code> 调用的 <code>do_syscall()</code> 函数。调用 <code>_yield</code> 实现<code>SYS_yield</code> 。根据手册我们需要对它进行封装，<code>SYS_yield</code>系统调用直接调用CTE的<code>_yield()</code>即可，然后返回<code>0</code>，系统调用的返回值我们通过<code>GPRx</code>来进行设置。</p><p>同时我们还需要实现一个退出的系统调用，它接收一个退出状态的参数, 用这个参数调用<code>_halt()</code>。</p><p>上述过程的代码如下：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240105163109990.png" alt="image-20240105163109990"></p><p>运行后我们成功得到一个 <code>GOOD TRAP!</code></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240106221357794.png" alt="image-20240106221357794"></p><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><p>因为前面埋下的雷所以被迫回头修bug^^ 这里一开始出错的原因是前面识别系统调用部分的 <code>GPRx</code> 的寄存器设置出错了，能通过上一小关但是在这里会导致一个bug无法正确输出。</p><p>解决问题之后这部分只要按手册实现 <code>SYS_write</code> 即可，然后在 <code>nanos.c</code> 文件中添加调用。</p><p>输出结果如下：</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240106155932827.png" alt="image-20240106155932827"></p><h3 id="堆区管理"><a href="#堆区管理" class="headerlink" title="堆区管理"></a>堆区管理</h3><p>我们程序加载进内存之后，其中存在一个名为用户程序的数据段的段，并且链接的时候<code>ld</code>会默认添加一个名为<code>_end</code>的符号, 来指示程序的数据段结束的位置(program break)，在这个结束位置之后的位置用户不能再随便往里面存东西， 必须通过<code>sbrk</code>来向系统申请，本质就是更新这个program break，通过<code>man 3 end</code>查阅了<code>_end</code>用法后，在用户层维护并更新这个program break即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> _end;</span><br><span class="line"><span class="type">void</span> *_sbrk(<span class="type">intptr_t</span> increment) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> program_break = &amp;_end;</span><br><span class="line">  <span class="type">int</span> ret = program_break;</span><br><span class="line">  <span class="keyword">if</span>(!_syscall_(SYS_brk, program_break + increment, <span class="number">0</span>, <span class="number">0</span>))&#123;</span><br><span class="line">    program_break += increment;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/17/pa-virtual-machine/image-20240106171754119.png" alt="image-20240106171754119"></p><h2 id="pa-3-3"><a href="#pa-3-3" class="headerlink" title="pa-3.3"></a>pa-3.3</h2><h3 id="简易文件系统"><a href="#简易文件系统" class="headerlink" title="简易文件系统"></a>简易文件系统</h3><p>修改Makefile文件，执行 <code>make clean</code> 清除<code>build/ramdisk.img</code>，然后update更新一下。</p><p>这部分就是完善 <code>fs.c</code> 中的各个函数，和上面类似完善 <code>syscall.c</code> 和 <code>nanos.c</code> 文件，还要修改原来的loader函数，不再使用 <code>ramdisk_disk()</code>.</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240106221107709.png" alt="image-20240106221107709"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240106220454526.png" alt="image-20240106220454526"></p><h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><h4 id="把串口抽象成文件"><a href="#把串口抽象成文件" class="headerlink" title="把串口抽象成文件"></a>把串口抽象成文件</h4><p>补充 <code>serial_write</code>，修改 <code>file_table</code>.</p><h4 id="把设备输入抽象成文件"><a href="#把设备输入抽象成文件" class="headerlink" title="把设备输入抽象成文件"></a>把设备输入抽象成文件</h4><p>补充<code>events_read</code>，然后在VFS中添加对<code>/dev/events</code>的支持，加载 <code>/bin/events</code></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240106234616123.png" alt="image-20240106234616123"></p><h4 id="把VGA显存抽象成文件"><a href="#把VGA显存抽象成文件" class="headerlink" title="把VGA显存抽象成文件"></a>把VGA显存抽象成文件</h4><p>按手册说的做，这里清晰且简单</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107004500077.png" alt="image-20240107004500077"></p><h2 id="pa-3-4"><a href="#pa-3-4" class="headerlink" title="pa-3.4"></a>pa-3.4</h2><h3 id="运行仙剑奇侠传"><a href="#运行仙剑奇侠传" class="headerlink" title="运行仙剑奇侠传"></a>运行仙剑奇侠传</h3><p>下载游戏数据然后传到虚拟机里并解压到要求的路径</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107170311082.png" alt="image-20240107170311082"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107165254108.png" alt="image-20240107165254108"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107165549573.png" alt="image-20240107165549573"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107165709639.png" alt="image-20240107165709639"></p><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>实现 <code>sys_execve</code> 系统调用</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107180955729.png" alt="image-20240107180955729"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107181434820.png" alt="image-20240107181434820"></p><h2 id="结果提交-1"><a href="#结果提交-1" class="headerlink" title="结果提交"></a>结果提交</h2><p><img src="/2023/12/17/pa-virtual-machine/image-20240107181702557.png" alt="image-20240107181702557"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240107181749020.png" alt="image-20240107181749020"></p><h1 id="pa4"><a href="#pa4" class="headerlink" title="pa4"></a>pa4</h1><h2 id="pa-4-1-实现基本的多道程序系统"><a href="#pa-4-1-实现基本的多道程序系统" class="headerlink" title="pa-4.1 实现基本的多道程序系统"></a>pa-4.1 实现基本的多道程序系统</h2><h3 id="实现上下文切换"><a href="#实现上下文切换" class="headerlink" title="实现上下文切换"></a>实现上下文切换</h3><p><img src="/2023/12/17/pa-virtual-machine/image-20240108161306497.png" alt="image-20240108161306497"></p><h3 id="实现多道程序系统"><a href="#实现多道程序系统" class="headerlink" title="实现多道程序系统"></a>实现多道程序系统</h3><p><img src="/2023/12/17/pa-virtual-machine/image-20240108191057493.png" alt="image-20240108191057493"></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240108191526459.png" alt="image-20240108191526459"></p><blockquote><p><strong>一山不容二虎</strong></p><p>结果如下</p><p><img src="/2023/12/17/pa-virtual-machine/image-20240109161357337.png" alt="image-20240109161357337"></p></blockquote><h1 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h1><p>2024.01.16：提交了！结束本科最后一门课程！</p><p>报告已上传GITHUB &#x3D;&gt; <a href="https://github.com/Elubrazione/report_hust/blob/main/%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%9F%B9%E5%85%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.pdf">here</a></p><p><img src="/2023/12/17/pa-virtual-machine/image-20240116161004692.png" alt="image-20240116161004692"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统能力培养虚拟机实验教程&lt;/p&gt;</summary>
    
    
    
    <category term="华科课程" scheme="https://elubrazione.github.io/categories/%E5%8D%8E%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>heterogeneous graphs</title>
    <link href="https://elubrazione.github.io/2023/11/27/cs224w-heterogeneous-graphs/"/>
    <id>https://elubrazione.github.io/2023/11/27/cs224w-heterogeneous-graphs/</id>
    <published>2023-11-27T10:41:02.000Z</published>
    <updated>2023-11-28T13:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>cs224w课程学习笔记</p><span id="more"></span><p>$G&#x3D;(V,E,R,T)$</p><p>node type $T(v_i)$, relation type $r \in R$</p><p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117200853873.png" alt="image-20231117200853873"></p><h2 id="RGCN"><a href="#RGCN" class="headerlink" title="RGCN"></a>RGCN</h2><p><strong>extend GCN</strong> to handle heterogeneous graph with miltiple edge&#x2F; relation types</p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117200917713.png" alt="image-20231117200917713" style="zoom:80%;"><p>we should use different neural network weights for different relation types</p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117200957472.png" alt="image-20231117200957472" style="zoom:80%;"><p>$$h^{(l+1)} _v &#x3D; \sigma(\sum \limits _{r \in R} \sum \limits _{u \in N^r _v} \frac{1}{c _{v,r}} W^{(l)} _r h^{(l)} _u + W^{(l)} _0 h^{(l)} _v)$$</p><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>each neighbor of a given relation:</p><p>$$m^{(l)} _ {u,r} &#x3D; \frac{1}{c_{v,r}} W^{(l)} _r h^{(l)} _u$$</p><p>self-loop:</p><p>$$m^{(l)} _v &#x3D; W^{(l)} _0 h^{(l)} _v$$</p><h4 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h4><p>sum over messages from neighbors and self-loop, then apply activation</p><p>$$h^{(l+1)} _v &#x3D; \sigma(Sum({ m^{(l)} _{u,r}, u \in {N(v)} \cup { v } }))$$</p><h3 id="scalability"><a href="#scalability" class="headerlink" title="scalability"></a>scalability</h3><p>如果有L层，那么对于每个关系就会有L个权重矩阵： $W^{(1)} _r, W^{(2)} _r…W^{(L)} _r$</p><p>而每个权重矩阵的大小 $W^{(l)} _r$ 是 $d^{(l+1)} \times d^{(l)}$</p><p>每个矩阵都有不同的尺寸，且随着类型以及隐藏层的数目增加，参数会呈现指数级的增长，模型就会变得太大，会出现过拟合以及无法训练的问题</p><h4 id="how-to-reduce-or-regularize"><a href="#how-to-reduce-or-regularize" class="headerlink" title="how to reduce or regularize?"></a>how to reduce or regularize?</h4><ul><li>use block diagonal matrices</li><li>basis&#x2F;dictionary learning</li></ul><h4 id="block-diagonal-matrices"><a href="#block-diagonal-matrices" class="headerlink" title="block diagonal matrices"></a>block diagonal matrices</h4><p>key：减少非0元素数量 &#x3D;&gt; 训练地更快，模型更robust，不容易过拟合</p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117201021773.png" alt="image-20231117201021773" style="zoom:80%;"><p>用B个低维矩阵，参数从$d^{(l+1)} \times d^{(l)}$减少到$\frac{d^{(l+1)}}{B} \times \frac{d^{(l)}}{B}$</p><p>只有相邻神经元&#x2F;嵌入维度可以通过权重矩阵交互，要解决这一限制，需要多加几层神经网络，或者用不同的block结构，才能让不在一个block内的维度互相交流。</p><blockquote><p><strong>解释一下这是为什么</strong></p><p>这个做法就是让把大矩阵给切成小块，比如原来的100×100按稀疏程度刚好能切成四个25×25的，设想以下场景：原来有23号和41号相连，但因为分区的存在23号只能和0号至24号交换信息，这就是所谓“只有同一个块里相邻的神经元才能交互”的意思。</p></blockquote><h4 id="basis-learning"><a href="#basis-learning" class="headerlink" title="basis learning"></a>basis learning</h4><p>key：在不同的关系中共享权重</p><p>将每个关系的权重矩阵表示为基变换的<strong>线性组合</strong></p><p>$$W_r &#x3D; \sum^{B} _ {b&#x3D;1} a _ {rb} \cdot V_b$$</p><p>这里$V_b$是共享的权重矩阵，$a_{rb}$是系数，这样我们就只需要训练和学习${ a_{rb} }^B _{b&#x3D;1}$ 就行</p><h3 id="example-entity-x2F-node-classification"><a href="#example-entity-x2F-node-classification" class="headerlink" title="example: entity&#x2F; node classification"></a>example: entity&#x2F; node classification</h3><p>如何定义各种任务？</p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117201048127.png" alt="image-20231117201048127" style="zoom:80%;"><h4 id="dataset-splitting"><a href="#dataset-splitting" class="headerlink" title="dataset splitting"></a>dataset splitting</h4><p>将每种关系对应的边都分成 training message edges, training supervision edges, validation edges, test edges 四类</p><p>&#x3D;&gt; 解决样本不平衡的问题，如果不先做边的分类直接将所有类型的边混在一起分成四份，无法保证四个数据集里含有所有关系类型的边</p><p>这么分完最后再合并到一起，合成大的四类</p><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231117201121446.png" alt="image-20231117201121446" style="zoom:80%;"><p>假设$(E,r_3,A)$是training supervision edge，其它所有的边都是training message edges。我们取E和A最后一层的embedding：$h^{(L)} _ E$和$h^{(L)} _ A$，然后使用一个函数$f_r: \mathbb{R}^d \times \mathbb{R}^d \to \mathbb{R}$来计算二者有关联的概率。例如 $f_{r1}(h_E,h_A)&#x3D;h^T_E W _{r1} h_A, W _{r1} \in \mathbb{R}^{d \times d}$</p><h4 id="training"><a href="#training" class="headerlink" title="training"></a>training</h4><blockquote><p><strong>negative edge</strong>的概念</p><p>既不属于training edges也不属于training supervision edges的边</p></blockquote><p><strong>用training message edges来预测training supervision edges</strong></p><ol><li><p>找到training supervision edges，比如图中的 $(E,r_3,A)$，用RGCN来对其打分（score）</p></li><li><p>增加一个negative edge来干扰supervision edge，因为这里supervision edge是从E到A的$r_3$类型的边，那么图中我们就可以增加$(E,r_3,B)$或者$(E,r_3,D)$或者$(E,r_3,F)$.</p></li><li><p>增加完negative edges之后我们也用RGCN来给其打分</p></li><li><p>使用交叉熵损失函数来优化，损失函数如下：</p><ol><li>最大化training supervision edges的分数</li><li>最小化negative edges的分数</li></ol><p>$$\mathscr{l} &#x3D; -log \sigma(f _{r3}(h_E,h_A)) - log(1-\sigma(f _{r3}(h_E,h_B)))$$</p></li></ol><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231118124030147.png" alt="image-20231118124030147" style="zoom:80%;"><h4 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h4><blockquote><p>因为在training的时候我们已经minimize了negative edge $(E,r_3,B)$的分数了，所以直觉上我们要预测的边$(E,r_3,D)$即validation edge的分数应该要比上面minimize score的negative edge高</p></blockquote><p>用training supervision edges和training message edges来预测validation edges</p><ol><li>用RGCN计算$(E,r_3,D)$分数</li><li>计算其它negative edges的分，在这里是${ (E,r_3,v) \mid v \in { B,F }}$</li><li>将以上的分数排序，获得$(E,r_3,D)$的排名RK，有两种指标：<ol><li>Hits@k: $1\space [RK \leq k]$，表示最后返回的前k个结果中命中的次数，因此命中次数越大越好；</li><li>Reciprocal Rank：$\frac{1}{RK}$，取倒数，排名越小越好，因此倒数越大越好.</li></ol></li></ol><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231118130103604.png" alt="image-20231118130103604" style="zoom:80%;"><h2 id="Knowledge-Graphs-Completion"><a href="#Knowledge-Graphs-Completion" class="headerlink" title="Knowledge Graphs Completion"></a>Knowledge Graphs Completion</h2><h3 id="embedding"><a href="#embedding" class="headerlink" title="embedding"></a>embedding</h3><blockquote><p>shallow embedding</p></blockquote><p>知识图谱中的边用一个三元组来表示$(h,r,t)$，节点头$h$和节点尾$t$有关系$r$，模型实体和关系都属于嵌入空间 $\mathbb{R}^d$</p><p>给定一个三元组，我们的嵌入目标是让$(h, r)$的嵌入向量接近$t$的嵌入向量。</p><ul><li>如何embed$(h, r)$</li><li>如何定义接近度</li></ul><p>最简单最自然的想法是transE：</p><ul><li>给定一个$(h,r,t)$，如果两点之间关系存在，则$h+r\approx t$；反之$h+r ≠ t$</li><li>得出$f _r (h, t) &#x3D; - \mid \mid h + r - t \mid \mid$</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128195513331.png" alt="image-20231128195513331" style="zoom:80%;"><h4 id="transE算法"><a href="#transE算法" class="headerlink" title="transE算法"></a>transE算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>常见关系：</p><ol><li><p>对称关系 </p><ul><li>$r(h, t) &#x3D;&gt; r(t, h)$ </li><li>你是我室友我也是你室友这叫对称</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128202132158.png" alt="image-20231128202132158" style="zoom:80%;"></li><li><p>反对称关系</p><ul><li>$(r(h,t) &#x3D;&gt; \neg r(t,h))$</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128201654905.png" alt="image-20231128201654905" style="zoom:80%;"></li><li><p>逆关系</p><ul><li>$r_2(h,t) &#x3D;&gt; r_1(t,h)$</li><li>雇佣和被雇佣</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128201713336.png" alt="image-20231128201713336" style="zoom:80%;"></li><li><p>复合传递关系</p><ul><li>$r_1(x, y) \land r_2(y,z) &#x3D;&gt; r_3(x,z)$ $\forall x,y,z$</li><li>我妈的老公是我爹：我和我妈是母女关系，我妈和某个人是夫妻关系，那么我和这个人是父女关系</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128201746886.png" alt="image-20231128201746886" style="zoom:80%;"></li><li><p>一对多关系</p><ul><li>$r(h,t_1),r(h,t_2),…,r(h,t_n)$都为真</li><li>一个老师可以有多个学生，$t1,t_2,…,t_n$都是学生</li></ul><img src="/2023/11/27/cs224w-heterogeneous-graphs/image-20231128202152055.png" alt="image-20231128202152055" style="zoom:80%;"></li></ol><blockquote><p>注意这里的反对称关系和传递性和离散数学里的定义有些不同，别搞混</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;cs224w课程学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://elubrazione.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum环境问题合集</title>
    <link href="https://elubrazione.github.io/2023/11/18/idsm-env-problems/"/>
    <id>https://elubrazione.github.io/2023/11/18/idsm-env-problems/</id>
    <published>2023-11-18T11:57:55.000Z</published>
    <updated>2023-12-20T21:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>毕业设计环境问题集锦，为了防止服务器到期需要remake环境</p><span id="more"></span><h1 id="Remake步骤"><a href="#Remake步骤" class="headerlink" title="Remake步骤"></a>Remake步骤</h1><blockquote><p>要安装在&#x2F;mydata下</p></blockquote><p>服务器环境安装分为四个部分</p><ol><li>Cloudlab服务器初始化</li><li><a href="https://elubrazione.github.io/2023/06/29/idsm-env-installation/#/%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8">Greenplum数据库安装</a></li><li><a href="https://elubrazione.github.io/2021/03/30/virtual-env-install/#/%E9%85%8D%E7%BD%AEGIT">配置Github SSH</a></li><li>安装Anaconda3（见下）</li></ol><h2 id="安装Anaconda3"><a href="#安装Anaconda3" class="headerlink" title="安装Anaconda3"></a>安装Anaconda3</h2><p>从网站 <a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a> 选择最新的Linux版本，复制连接</p><p><img src="/2023/11/18/idsm-env-problems/image-20231118202402770.png" alt="image-20231118202402770"></p><p>打开服务器，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">chmod</span> +x Anaconda3-2023.09-0-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">sudo</span> ./Anaconda3-2023.09-0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>启动安装程序后一路回车，是否允许安装时输入yes，重定向安装目录，然后回车。</p><p>安装完成后添加一下系统变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim ~/bashrc</span><br><span class="line"><span class="comment"># 添加以下内容，后面是安装目录</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/anaconda3/bin</span><br><span class="line"><span class="comment"># 退出后</span></span><br><span class="line"><span class="built_in">source</span> ~/bashrc</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">conda info --<span class="built_in">env</span></span><br><span class="line">conda</span><br></pre></td></tr></table></figure><p>创建环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name postgres python=3.7</span><br><span class="line"><span class="built_in">source</span> activate postgres</span><br></pre></td></tr></table></figure><p><img src="/2023/11/18/idsm-env-problems/image-20231118204641445.png" alt="image-20231118204641445"></p><p>补充：每次重新启动服务器都要重新<code>source ~/bashrc</code></p><h1 id="重构遇到的环境问题"><a href="#重构遇到的环境问题" class="headerlink" title="重构遇到的环境问题"></a>重构遇到的环境问题</h1><h2 id="脚本无权限"><a href="#脚本无权限" class="headerlink" title="脚本无权限"></a>脚本无权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./env.sh</span><br></pre></td></tr></table></figure><h2 id="greenplum重置python"><a href="#greenplum重置python" class="headerlink" title="greenplum重置python"></a>greenplum重置python</h2><p>写了个脚本一键恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./env.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕业设计环境问题集锦，为了防止服务器到期需要remake环境&lt;/p&gt;</summary>
    
    
    
    <category term="腾讯AI训练营" scheme="https://elubrazione.github.io/categories/%E8%85%BE%E8%AE%AFAI%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="环境问题" scheme="https://elubrazione.github.io/tags/%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HUST图神经网络Devign模型</title>
    <link href="https://elubrazione.github.io/2023/11/12/devign/"/>
    <id>https://elubrazione.github.io/2023/11/12/devign/</id>
    <published>2023-11-12T12:13:06.000Z</published>
    <updated>2023-12-31T09:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇论文的方向是安全邻域的代码漏洞识别问题。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序漏洞是软件安全的主要威胁之一，然而在开发阶段几乎不可能避免漏洞；甚至很难在生产阶段发现漏洞。源代码缺陷检测是判别程序代码中是否存在非预期行为的过程，广泛应用于软件测试、软件维护等软件工程任务，对软件的功能保障与应用安全方面具有至关重要的作用。安全专家通常利用动态模糊测试、符号执行或静态代码审计来发现漏洞。然而，这些技术都不能提供一个很好的解决方案：动态模糊测试存在代码覆盖问题和初始种子问题；由于路径爆炸和约束解决问题，符号执行不能很好地扩展到现实世界的程序中；静态代码审计通常需要人类的专业知识，当程序复杂性增加时，它不能进行很好地扩展<a href="#ref-1">$^{[1]}$</a>。</p><p>由于代码具备各个维度的特征，例如局部的文本共现特征与长程的数据、控制依赖特征，因此，如何对代码进行表征成为了设计深度学习模型需首要考虑的问题。当前的方法主要通过序列、树和图对代码进行表征，其常用的对应网络结构<a href="#ref-2">$^{[2]}$</a>如图1-1所示。</p><p><img src="/2023/11/12/devign/image-20231114210730098.png" alt="image-20231114210730098" title="图1-1.代码表征的分类与应用模型"></p><p>现有的方法在学习综合程序语义以表征高多样性、脆弱性以及真实世界的代码的复杂性方面都有很大的局限<a href="#ref-3">$^{[3]}$</a>。可以将现有方法的缺点总结为以下三点：</p><p>1）<strong>对源代码结构和逻辑的简化</strong>：传统的学习方法将源代码视为平面序列或仅使用部分信息来表示代码，忽略了源代码的结构性和逻辑性。源代码通常具有抽象语法树、数据流、控制流等复杂的表示方式，这些信息对于准确理解代码含义是至关重要的。</p><p>2）<strong>缺乏综合检测漏洞的能力</strong>：源代码中的漏洞有时是微妙的缺陷，需要从语义的多个维度进行综合调查才能发现。然而，现有方法在设计上存在缺陷，限制了其发现各种漏洞的潜力。</p><p>3）<strong>训练数据的问题</strong>：部分数据是由静态分析器标注的，这导致了高比例的误分类，即被标记为漏洞但实际上并不是真正的漏洞。另一部分数据是人工编写的简单代码，相比于真实世界的代码过于简单。</p><p>本文提出了一种基于图神经网络的新型模型，该模型采用复合编程表示法来处理事实漏洞数据，能够编码一整套经典的编程代码语义，以捕捉各种脆弱性特征。本文的创新点如下：</p><p>1）首次使用图的数据结构，并将不同层次的程序控制和数据依赖关系编码成一个由异质边组成的联合图，每条异质边 $^1$ 上的类型表示与相应表征的连接，这样有利于捕获尽可能广泛的漏洞类型和模式，并能够通过图神经网络学习更好的节点表示；</p><p>2）提出了一个新的带卷积模块的门控图神经网络模型，用于图级别的分类，有利于捕捉更高层次的图特征；</p><p>3）收集了许多手工标记的数据集并准确、有效验证了模型的性能，实验结果显示：本模型在缺陷检测任务的效果上显著高于之前方法；同时，在112个真实项目的缺陷函数中检测准确率达到74%。</p><blockquote><p>$^1$ 异质边（Heterogeneous edges）是指在图结构中连接不同类型节点之间的边。在异质图（Heterogeneous graph）中，节点可以表示不同的实体或概念，而异质边则表示这些实体或概念之间的关系或连接。异质边的存在使得我们能够在图结构中更好地捕捉不同实体之间的复杂关系和连接模式，从而提供更准确和全面的图分析和挖掘能力。</p></blockquote><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型包含三个部分：1）复合代码语义的图嵌入层；2）门控图循环层；3）卷积层模块。各自功能如下：</p><ul><li>将源代码编码成具有综合程序语义的联合图结构；</li><li>通过消息传递和消息聚合邻居节点的信息以学习每个节点特征；</li><li>提取有用的节点表征用于图层面的预测。</li></ul><p><img src="/2023/11/12/devign/image-20231113151131971.png" alt="image-20231113151131971"></p><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>可以将代码漏洞检测问题转换为一个二元分类问题，即给定一个源代码，判定其是否存在函数级别的代码漏洞。</p><p>假设代码数据样本定义为：</p><p>$$((c_i,y_i) \mid c_i \in \mathcal{C}, y_i \in \mathcal{Y}), i \in { 1,2,…,n }$$</p><p>其中 $\mathcal{C}$ 表示代码中的函数集； $\mathcal{Y}&#x3D;{ 0,1 }^{n}$ 中1表示有代码漏洞易受攻击，0表示无； $n$ 是实例个数。</p><ul><li>把每个函数 $c_i$ 编码成一个多边图 $g_i(V,X,A) \in \mathcal{G}$；</li><li>$m$ 是 $V$ 的节点个数；</li><li>$X \in\mathbb{R}^{m \times d}$ 是初始节点特征矩阵，每个节点 $v_j$ 被表示为一个 $d$ 维的向量 $x_j \in \mathbb{R}^{d}$ （即每个节点的特征是 $1\times d$ ， $V$ 中一共有 $m$ 个节点，因此 $\mathbb{R}$ 的大小是 $m \times d$ ）；</li><li>邻接矩阵 $A \in { 0,1}^{k \times m \times m}$ ，其中 $k$ 是边类型的总数， $e^{p} _ {s,t} \in A$ 等于1表示节点 $v_s$ 和 $v_t$ 通过类型 $p$ 的边相连，否则为0（每个节点都有可能与其它节点有 $p$ 种类型的边相连，因此大小为 $k \times m \times m$ ）</li></ul><p>所以模型的目标是学习从 $\mathcal{G}$ 到 $\mathcal{Y}$ 的映射 $f: \mathcal{G} \mapsto \mathcal{Y}$ 来预测一个函数里是否存在漏洞，使用交叉熵损失函数，并使用可调权重 $\lambda$ 进行正则化 $\omega(·)$ ，我们需要做的就是最小化：</p><p>$$\sum\limits _ {i&#x3D;1}^{n} \mathcal{L}(f(g_i(V,X,A),y_i|c_i))+\lambda\omega(f)$$</p><h3 id="复合代码语义的图嵌入"><a href="#复合代码语义的图嵌入" class="headerlink" title="复合代码语义的图嵌入"></a>复合代码语义的图嵌入</h3><p>常见的代码程序表示方法有抽象语法树、控制流和数据流图（编译原理学过的那些）。比较优秀的漏洞检测方法需要结合这三种表示方法形成一个联合数据结构，同时本模型还考虑了源代码的自然序列，即一共四种表示方法。具体做法为：</p><p>将函数 $c_i$ 用联合图 $g_i$ 表示，其中四类子图共享同一组节点 $V&#x3D;V^{ast}$ ，这里的每个节点 $v \in V$ 都有两个属性： $Code$ 和 $Type$ 。 $Code$ 属性通过使用预训练的word2vec模型对源代码进行编码来表示，而 $Type$ 属性则表示节点的类型；然后再将 $Code$ 和 $Type$ 的编码连接在一起，形成初始节点表示 $x_v$ ，以便在后续的图神经网络或图表示学习中使用。这样，每个函数 $c_i$ 都可以通过一个联合图 $g$ 来表示，并且可以利用这个联合图来进行进一步的分析和学习。</p><h3 id="门控图循环网络"><a href="#门控图循环网络" class="headerlink" title="门控图循环网络"></a>门控图循环网络</h3><p>给定一个嵌入图 $g_i(V,X,A)$ ，对于每个节点 $v_j \in V$ ，状态向量 $h^{(1)} _ j$ 被初始化为 $[x^\intercal_j,0]^\intercal$ ，这里因为 $h^{(1)} _j \in \mathbb{R}^z, z \geq d$ ，所以多余的位置被用0来填充。</p><p>在每个时刻 $t \leq T$ 中，节点之间通过相应的边类型和方向进行信息传递。邻接矩阵 $A_p$ 描述了从节点 $v_j$ 到其他节点的连接情况，通过在每个时间步中执行这样的邻居聚合操作，可以在整个图中传播和聚合信息，从而使每个节点能够获取来自邻居节点的上下文信息，并将其整合到自身的状态中。</p><p>具体，到达 $t$ 时刻，对于某个节点$j$的某种类型 $p$ 拉邻接结点进行信息传播后的结果为：</p><p>$$a^{(t-1)} _{j,p} &#x3D; A^\intercal_p (W_p [h^{(t-1)\intercal} _1,…,h^{(t-1)\intercal} _m] + b)$$</p><p>我对以上的公式进行了改造以助于理解：</p><p>$$a^{(t-1)} _{j,p} &#x3D; \sum\limits _ {u \in N(v)} W_p \frac{h^{(t-1)}_u}{\mid N(v) \mid} +b$$</p><p>这里 $N(v)$ 表示节点 $u$ 的邻接结点，乘上 $A^\intercal_p$ 就是为了过滤掉非邻接结点。</p><p>然后对传递的信息进行聚合，这里 $AGG(·)$ 可以是任何函数，如 $Sum(·)，Mean(·)，Max(·)$ ，CS224W的课程里有提到一般情况下 $Sum(·)$ 性能是最佳的，此论文也用了该函数。</p><p>因此当前时刻节点的隐藏状态就可以通过前一时刻的隐藏状态和聚合后的邻居信息表现为：</p><p>$$h^{(t)} _j &#x3D; GRU(h^{(t-1)} _j, AGG( { a^{(t-1)} _{j,p} }^k _{p&#x3D;1}))$$</p><p>在经历了$T$时刻这样的更新后， $H^{(T)} _i &#x3D; { h^{(T)} _j }^m _{j&#x3D;1}$ （即所有节点最后一个隐藏层表示的并集）就是最后集合 $V$ 的节点表示。</p><h3 id="卷积模块"><a href="#卷积模块" class="headerlink" title="卷积模块"></a>卷积模块</h3><blockquote><p>这里就是实验要求实现的部分</p></blockquote><p>应用一维卷积和全连接层来学习与图级任务相关的特征，以获得更有效的预测。定义 $\sigma(·)$ 算子如下：</p><p>$$\sigma(·) &#x3D; MAXPOOL(Relu(CONV(·)))$$</p><p>它将输入的特征进行卷积操作，并通过ReLU激活函数进行非线性变换，然后使用最大池化对卷积结果进行下采样。</p><p>同时为了利用每个节点本身的信息，devign分别训练了两个卷积模块，得到特征：</p><p>$$Z^{(1)} _i &#x3D; \sigma([H^{(T)} _i, x_i]),…,Z^{(l)} _i &#x3D; \sigma(Z^{(l-1)} _i)$$</p><p>$$Y^{(1)} _i &#x3D; \sigma(H^{(T)} _i),…,Y^{(l)} _i &#x3D; \sigma(Y^{(l-1)} _i)$$</p><p>最后再将两个特征输入到MLP中，然后对乘法结果进行平均聚合，最后使用Sigmoid激活函数将其映射到[0, 1]的范围内，得到节点的预测结果。</p><p>$$\tilde{y_i} &#x3D; Sigmoid(AVG(MLP(Z^{(l)} _i) \odot MLP(Y^{(l)} _i)))$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>configs.json</code> 配置文件包含了各个配置类所需的参数值，用于配置代码的行为和功能。它定义了不同类别的配置参数，如Devign模型、数据创建、路径、文件、代码嵌入和处理等。configs.py文件就是安装 <code>configs.json</code> 文件中最外层的键创建了一些对应的类供再上层获取参数，调用的地方就在 <code>main.py</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE_PARAMS = configs.Create()</span><br><span class="line">PROCESS_PARAMS = configs.Process()</span><br><span class="line">PATHS = configs.Paths()</span><br><span class="line">FILES = configs.Files()</span><br><span class="line">DEVICE = PROCESS_PARAMS.device</span><br></pre></td></tr></table></figure><p>这里的 <code>DEVICE</code> 是根据 <code>torch.cuda.is_available() and self.get_property(&quot;use_gpu&quot;)</code>得到的。</p><p>这里我总结了一下 <code>configs.py</code> 里的类的功能，大致如下：</p><ul><li>Config一个基础配置类，用于加载和访问配置文件中的参数；</li><li>Create类用于访问创建CPG数据相关的配置参数，如过滤条件、切片大小、Joern CLI目录和数据集大小等；</li><li>Data类用于访问数据相关的配置参数，包括CPG数据、原始数据、输入数据、模型数据、标记数据和词向量数据等；</li><li>Paths类用于访问路径相关的配置参数，如CPG数据路径、Joern路径和其他数据路径等；</li><li>Files类用于访问文件相关的配置参数，如原始数据文件、CPG文件、标记文件、词向量文件和模型文件等；</li><li>Embed类用于访问代码嵌入相关的配置参数，如最大节点数、Word2Vec参数和边类型等；</li><li>Process类用于访问训练和评估模型相关的配置参数，如训练轮数、早停策略、批处理大小、设备选择等；</li><li>Devign类用于访问Devign模型相关的配置参数，包括学习率、权重衰减、损失函数参数和模型参数等。</li></ul><h3 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup()"></a>setup()</h4><p>创建 <code>Path()</code> 里定义的文件夹，我们到 <code>configs.json</code> 里可以看到，路径为 <code>data/*</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cpg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/cpg/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;joern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/joern/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;raw&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/raw/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/input/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/model/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/tokens/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;w2v&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data/w2v/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><code>data/raw</code>&#x2F; 存放着我们在第一步里探索的原始代码数据集，<code>data/cpg/</code> 存放着我们从根目录的压缩包里解压出来的用joern工具生成的CPG图。</p><p>执行完第二步的 <code>main.setup()</code> 就会创建其它文件夹以供后续使用。</p><img src="/2023/11/12/devign/image-20231114102402956.png" alt="image-20231114102402956" style="zoom:;"><h4 id="embed-task"><a href="#embed-task" class="headerlink" title="embed_task()"></a>embed_task()</h4><p>画了个代码流程图</p><pre class="mermaid">graph TB    A(开始)-->B[获取文件路径]    B[获取文件路径]--调用data.get_directory_file-->C[获取.pkl文件路径列表]    C-->D{遍历列表完成?}    D--未完成-->E[加载CPG数据集]    E--源代码分词-->F[获取分词结果并写入token文件夹]    F--初始化Word2Vec-->G[创建模型对象w2vmodel]    G-->I[学习每个标记的初始嵌入]    E-->J[将CPG转换为节点表示]    I-->K    J-->K[使用Word2Vec模型对每一个节点的文本进行编码]    K-->L[保存结果到input文件夹]    D--完成-->M[保存Word2Vec模型到为w2v文件夹]    L-->N(结束)    M-->N</pre><h4 id="process-task"><a href="#process-task" class="headerlink" title="process_task()"></a>process_task()</h4><p>前半部分是Devign模型初始化，模型初始化的时候用到了configs.Devign()里用到的参数。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;devign&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;learning_rate&quot;</span><span class="punctuation">:</span> <span class="number">1e-4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight_decay&quot;</span><span class="punctuation">:</span> <span class="number">1.3e-6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loss_lambda&quot;</span><span class="punctuation">:</span> <span class="number">1.3e-6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gated_graph_conv_args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;out_channels&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;num_layers&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;aggr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;bias&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;emb_size&quot;</span><span class="punctuation">:</span> <span class="number">101</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>后半部分是训练的代码，流程图如下。这里需要说明的是，根据 <code>./process/modeling.py</code> 的 <code>Train()</code> 函数，早停版本训练里计算验证集的loss后需要确认验证集的loss是否下降，如果下降的话就保存当前模型的参数到 <code>./data/model/</code> 目录下，命名为 <code>checkpoint.pt</code>，之后会 从 <code>Net()</code> 类的 <code>load()</code> 方法里加载该参数以进行后续的测试集测试。而如果只是普通训练会根据 <code>configs.json</code> 里定义的200轮训练并保存模型。 </p><pre class="mermaid">graph TB    A(开始)-->B[加载配置并初始化模型]    B-->C[从本地加载数据集]    C-->D[数据集划分及创建加载器]    D-->E[创建训练器train]    E-->F{TEST_ONLY?}    F--YES-->G[测试]    F--NO-->H{EarlyStop模式?}    H--YES-->I[设置早停参数]    I-->J[早停训练]    J-->K[加载检测点模型参数]    K-->G    H--NO-->L[普通训练]    L-->M[保存模型]    M-->G    G-->Z(结束)</pre><p><code>Train</code> 的调用方法里数据集迭代器用的不是我们平常用的 <code>DataLoader</code>，而是自己封装的一个类似功能的 <code>LoaderStep</code> 类，里面又嵌套调用了 <code>Stats</code> 类来计算损失和准确率。同时 <code>Train</code> 里调用了一个封装的 <code>History</code> 类来进行控制台打印和log文件写入。</p><p>值得一提的是在跑完一个结果后我又仔细看了一下代码，早停训练原来并不是固定的10轮后就停止，根据 <code>./process/stopping.py</code> 里的 <code>EarlyStopping</code> 的代码，应该是验证集的loss没有下降后默认十轮（也是由 <code>configs.json</code> 文件定义）停止。而我第一次跑的过程中，Epoch1里loss从正无穷大到0.693208下降，保存了一个测试点模型，而Epoch2开始后面验证集loss都没有下降，所以又跑了十轮停止。而如果在Epoch2之后出现了loss下降则会重新保存模型出发新的一套十轮EarlyStop计数。</p><p><img src="/2023/11/12/devign/image-20231115153530192.png" alt="image-20231115153530192"></p><p>看这份代码我的感想是各个函数分装地非常清楚，很多我以前会写在一起的功能在这份代码里都进行了分装，在一开始我并不清楚某些功能具体是怎么实现的（比如EarlyStop和LoaderStep），只是大概知道是干什么的，也完全不影响我跑实验，同时在阅读代码的时候确实感到比较清晰，层层递进。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><p>好久没用，check一下本地的环境</p><img src="/2023/11/12/devign/image-20231113200013619.png" alt="image-20231113200013619" style="zoom:80%;"><p>根据torch-geometric官方的教程安装一下这个包（看起来已经迭代到了比较好安装的样子，网上很多以前的安装教程还挺麻烦的）同时根据requirement.txt文件安装一下对应的包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br><span class="line">conda install pyg -c pyg</span><br><span class="line">pip install -r ./requirements.txt</span><br></pre></td></tr></table></figure><p>解压一下数据集</p><img src="/2023/11/12/devign/image-20231113205622718.png" alt="image-20231113205622718"><p>按指南探索一下代码数据集</p><img src="/2023/11/12/devign/image-20231113203358944.png" alt="image-20231113203358944"><p>执行第二步代码文本编码，完成word2vec模型的训练</p><img src="/2023/11/12/devign/image-20231114095444872.png" alt="image-20231114095444872"><p>这是控制台调用 <code>embed_task()</code> 打印的东西</p><img src="/2023/11/12/devign/image-20231114095538325.png" alt="image-20231114095538325"><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p>根据论文里的内容，利用每个节点本身的信息，分别训练了两个卷积模块，最后再将两个特征输入到MLP中，然后对乘法结果进行平均聚合，最后使用Sigmoid激活函数将其映射到[0, 1]的范围内，得到节点的预测结果。按照公式摸出来就行。这里我设计了两个两层的卷积模块和对应的池化层，参数如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置卷积层和池化层参数</span></span><br><span class="line"><span class="variable language_">self</span>.conv1_size = &#123;</span><br><span class="line">    <span class="string">&quot;in_channels&quot;</span>: <span class="variable language_">self</span>.max_nodes,</span><br><span class="line">    <span class="string">&quot;out_channels&quot;</span>: <span class="number">64</span>,</span><br><span class="line">    <span class="string">&quot;kernel_size&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">self</span>.conv2_size = &#123;</span><br><span class="line">    <span class="string">&quot;in_channels&quot;</span>: <span class="number">64</span>,</span><br><span class="line">    <span class="string">&quot;out_channels&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;kernel_size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">self</span>.maxp1_size = &#123;</span><br><span class="line">    <span class="string">&quot;kernel_size&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;stride&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">self</span>.maxp2_size = &#123;</span><br><span class="line">    <span class="string">&quot;kernel_size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;stride&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.feature1 = nn.Conv1d(**<span class="variable language_">self</span>.conv1_size)</span><br><span class="line"><span class="variable language_">self</span>.maxpool1 = nn.MaxPool1d(**<span class="variable language_">self</span>.maxp1_size)</span><br><span class="line"><span class="variable language_">self</span>.feature2 = nn.Conv1d(**<span class="variable language_">self</span>.conv2_size)</span><br><span class="line"><span class="variable language_">self</span>.maxpool2 = nn.MaxPool1d(**<span class="variable language_">self</span>.maxp2_size)</span><br></pre></td></tr></table></figure><p>对于两个特征$Z$和$Y$对应的卷积层后面都要接全连接层，全连接层的第一个参数由老师给的函数 <code>get_conv_mp_out_size()</code> 计算（但是在后面实验的过程中其实遇到了一些小问题）调用传入的第一个参数需要由前面的图神经网络的参数计算，所以需要在初始化函数里添加图神经网络的 <code>out_channels</code> 和 <code>emb_size</code>，根据公式：</p><p>$$Z^{(1)} _i &#x3D; \sigma([H^{(T)} _i, x_i])$$</p><p>$$Y^{(1)} _i &#x3D; \sigma(H^{(T)} _i)$$</p><p>$Z$的$h$和$w$应该是<code>graph_out_chs + emb_size</code>，而$Y$的$h$和$w$就只有 <code>graph_out_chs</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据conv和maxpool参数计算mlp尺寸</span></span><br><span class="line"><span class="variable language_">self</span>.mlp1_size = get_conv_mp_out_size(</span><br><span class="line">    graph_out_chs + emb_size,</span><br><span class="line">    <span class="variable language_">self</span>.conv2_size,</span><br><span class="line">    [<span class="variable language_">self</span>.maxp1_size, <span class="variable language_">self</span>.maxp2_size]</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.mlp2_size = get_conv_mp_out_size(</span><br><span class="line">    graph_out_chs,</span><br><span class="line">    <span class="variable language_">self</span>.conv2_size,</span><br><span class="line">    [<span class="variable language_">self</span>.maxp1_size, <span class="variable language_">self</span>.maxp2_size]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.mlp1 = nn.Linear(<span class="number">1200</span>, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">self</span>.mlp2 = nn.Linear(<span class="variable language_">self</span>.mlp2_size, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在前向传播过程中，对于 $Z$，首先需要将输入的h和x在特征维度上进行拼接，再进行reshape操作，接着通过两个 $\sigma(·)$ 算子（即我们前面定义好的两层卷积层、激活层和对应的最大池化层），然后将得到的张量展平，输入到第一个全连接层中中。$Y$ 的操作同理，唯一的区别就是不进行h和x的拼接。最后，将两个结果相乘并展平为一维张量，并经过Sigmoid激活函数得到最终的输出结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, h, x</span>):</span><br><span class="line">    z_feature = torch.cat([h, x], <span class="number">1</span>)</span><br><span class="line">    z_feature = z_feature.view(-<span class="number">1</span>, <span class="variable language_">self</span>.max_nodes, h.shape[<span class="number">1</span>] + x.shape[<span class="number">1</span>])</span><br><span class="line">    out_z = <span class="variable language_">self</span>.maxpool1(F.relu(<span class="variable language_">self</span>.feature1(z_feature)))</span><br><span class="line">    out_z = <span class="variable language_">self</span>.maxpool2(F.relu(<span class="variable language_">self</span>.feature2(out_z)))</span><br><span class="line">    out_z = out_z.view(-<span class="number">1</span>, <span class="built_in">int</span>(out_z.shape[<span class="number">1</span>] * out_z.shape[-<span class="number">1</span>]))</span><br><span class="line">    out_z = <span class="variable language_">self</span>.mlp1(out_z)</span><br><span class="line"></span><br><span class="line">    y_feature = h.view(-<span class="number">1</span>, <span class="variable language_">self</span>.max_nodes, h.shape[<span class="number">1</span>])</span><br><span class="line">    out_y = <span class="variable language_">self</span>.maxpool1(F.relu(<span class="variable language_">self</span>.feature1(y_feature)))</span><br><span class="line">    out_y = <span class="variable language_">self</span>.maxpool2(F.relu(<span class="variable language_">self</span>.feature2(out_y)))</span><br><span class="line">    out_y = out_y.view(-<span class="number">1</span>, <span class="built_in">int</span>(out_y.shape[<span class="number">1</span>] * out_y.shape[-<span class="number">1</span>]))</span><br><span class="line">    out_y = <span class="variable language_">self</span>.mlp2(out_y)</span><br><span class="line"></span><br><span class="line">    out = out_z * out_y</span><br><span class="line">    out = torch.sigmoid(torch.flatten(out))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="开跑"><a href="#开跑" class="headerlink" title="开跑"></a>开跑</h3><p>嗯…好的，把配置文件的 <code>process.use_gpu</code> 改成 <code>false</code>（破电脑是这样的ToT）然后重启ipynb文件</p><img src="/2023/11/12/devign/image-20231114155146274.png" alt="image-20231114155146274"><p>打印显示了 <code>train with cpu</code></p><img src="/2023/11/12/devign/image-20231114163514925.png" alt="image-20231114163514925"><p>出了bug，调用老师给的函数 <code>get_conv_mp_out_size()</code> 算出来的是1216，但是实际是1200所以对不上，暴力修改Linear层的第一个参数为1200。</p><p><img src="/2023/11/12/devign/image-20231114163529980.png" alt="image-20231114163529980"></p><p>第二个倒是没出问题</p><img src="/2023/11/12/devign/image-20231114164228172.png" alt="image-20231114164228172"><p>跑出一个batch_loss了</p><p><img src="/2023/11/12/devign/image-20231114164323043.png" alt="image-20231114164323043"></p><p>继续放着跑吧，看到 <code>EarlyStopping=True</code> 应该是会跑十轮然后自己停</p><img src="/2023/11/12/devign/image-20231114164617782.png" alt="image-20231114164617782"><p>跑完了</p><img src="/2023/11/12/devign/image-20231114165740838.png" alt="image-20231114165740838"><p>结果</p><img src="/2023/11/12/devign/image-20231114172606621.png" alt="image-20231114172606621"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a id="ref-1">[1]</a> Xu Z, Chen B, Chandramohan M, et al. Spain: security patch analysis for binaries towards understanding the pain and pills[C]&#x2F;&#x2F;2017 IEEE&#x2F;ACM 39th International Conference on Software Engineering (ICSE). IEEE, 2017: 462-472.</p><p><a id="ref-2">[2]</a> 邓枭, 叶蔚, 谢睿, 等. 基于深度学习的源代码缺陷检测研究综述[J]. 软件学报, 2023, 34(2): 625-654.</p><p><a id="ref-3">[3]</a> Zhou Y, Liu S, Siow J, et al. Devign: Effective vulnerability identification by learning comprehensive program semantics via graph neural networks[J]. Advances in neural information processing systems, 2019, 32.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇论文的方向是安全邻域的代码漏洞识别问题。&lt;/p&gt;</summary>
    
    
    
    <category term="华科课程" scheme="https://elubrazione.github.io/categories/%E5%8D%8E%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>graph neural network</title>
    <link href="https://elubrazione.github.io/2023/11/11/cs224w-graph-neural-network/"/>
    <id>https://elubrazione.github.io/2023/11/11/cs224w-graph-neural-network/</id>
    <published>2023-11-11T03:55:44.000Z</published>
    <updated>2023-11-17T10:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>图机器学习学习笔记</p><span id="more"></span><h2 id="deep-learning-for-graphs"><a href="#deep-learning-for-graphs" class="headerlink" title="deep learning for graphs"></a>deep learning for graphs</h2><p>图网络要复杂得多:</p><ul><li>尺寸任意，拓扑结构复杂</li><li>没有固定的节点顺序或参考点</li><li>通常是动态的，具有多模态特征</li></ul><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109152304390.png" alt="image-20231109152304390" style="zoom:80%;"><p>将ajacency matrix和node feature结合送入网络存在以下问题</p><ul><li>$O(\mid V \mid)$参数太大</li><li>不适用于不同大小的图</li><li>对节点排序敏感</li></ul><p>如果套用CNN的话，没有固定的notion of locality或者sliding window在一个卷积核内，以及graph的同构性从不同角度看会不一样但图是permutation invariant的</p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109153623998.png" alt="image-20231109153623998" style="zoom:67%;"><h3 id="permutation-invariance-x2F-equivariance"><a href="#permutation-invariance-x2F-equivariance" class="headerlink" title="permutation invariance &#x2F; equivariance"></a>permutation invariance &#x2F; equivariance</h3><ul><li>置换不变性<ul><li>对于图嵌入</li><li>节点的排序不会改变图的表示</li></ul></li><li>排列不变性<ul><li>对于节点嵌入</li><li>节点的排序将导致节点表示的相同排序</li></ul></li></ul><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109153747448.png" alt="image-20231109153747448"></p><p>对于上面的两个图，embedding函数$f(Ai, Xi)$产生的结果应该是一样的，这样的函数就说其是permutation invariance</p><p>Graph neural networks consist of multiple permutation equivariant &#x2F; invariant functions.</p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109234914593.png" alt="image-20231109234914593" style="zoom:80%;"><h2 id="a-general-perspective-on-graph-neural-network"><a href="#a-general-perspective-on-graph-neural-network" class="headerlink" title="a general perspective on graph neural network"></a>a general perspective on graph neural network</h2><p>如果借用CNN的思维的话即从邻居那得到咨询然后做卷积，这种即GCN。我们需要定义邻居以及让模型学会如何得到邻居的信息（aggregate infomation）</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109235335160.png" alt="image-20231109235335160"></p><p>receptive field在cnn里指的是卷积核的视野，在graph里是指拉neighbors的次数，一阶邻居、二阶邻居，receptive field越大能看到的范围越大。当邻居的info拿到后要做平均，然后使用一个nn做更新。</p><h3 id="math-of-graph-convolution"><a href="#math-of-graph-convolution" class="headerlink" title="math of graph convolution"></a>math of graph convolution</h3><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231109235748828.png" alt="image-20231109235748828"></p><p>$h^{(k)}_u$ 是node-v邻居的embedding，加起来除以邻居的数量，即蓝色部分是在平均邻居的咨询。而这样缺少了自身的咨询，因为要加上红色部分node-v本身的咨询 $h^{(k)}_v$。注意加上前需要分别乘上weight进行transform，得到和后使用非线性函数激活。这样就是一次的convolution即1-layer（注意这里因为permutation invariance &#x2F; equivalence所以拉邻居的顺序不会影响最后的结果）</p><blockquote><p> 但当graph的node很多的时候复杂度会很高，因此我们需要借助matrix operation</p></blockquote><h3 id="matrix-formulation"><a href="#matrix-formulation" class="headerlink" title="matrix formulation"></a>matrix formulation</h3><p>拉邻居加起来的过程就可以看作是邻接矩阵乘上embedding matrix，在用度矩阵degree做一个平均。</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231110000857553.png" alt="image-20231110000857553"></p><h3 id="gnn-framework"><a href="#gnn-framework" class="headerlink" title="gnn framework"></a>gnn framework</h3><p>gnn layer &#x3D; message + aggregation，现在不同的gnn的区别是他们产生message的方法或者aggregate的方法不同；</p><p>借由叠加多层的layer，看到的视野更大，而不同的层数之间也可以像cnn一样使用dropout来更powerful；</p><p>有时候一个graph可能本身没有feature只有一个结构，又或者是graph的结构太复杂&#x2F;稀疏，我们可以做feature augmentation &#x2F; structure augmentation，即raw input graph ≠ computational graph.</p><p>learning objective: Supervised &#x2F; Unsupervised objectives, Node&#x2F;Edge&#x2F;Graph level objectives;</p><h3 id="inductive-capability"><a href="#inductive-capability" class="headerlink" title="inductive capability"></a>inductive capability</h3><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231110001903062.png" alt="image-20231110001903062"></p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231110001955737.png" alt="image-20231110001955737"></p><h2 id="a-single-layer-of-a-gnn"><a href="#a-single-layer-of-a-gnn" class="headerlink" title="a single layer of a gnn"></a>a single layer of a gnn</h2><h3 id="theory"><a href="#theory" class="headerlink" title="theory"></a>theory</h3><h4 id="message-function"><a href="#message-function" class="headerlink" title="message function"></a>message function</h4><p>message function是在对邻居的node embedding做一些转换，让它更好再传给当前node</p><p>$m^{(l)}_u &#x3D; MSG^{(l)}(h^{(l-1)} _ {u})$</p><p>这里的$MSG$可以是任何形式的layer，可以是linear也可以是non-linear，甚至可以是multi-layers的</p><h4 id="aggregation-function"><a href="#aggregation-function" class="headerlink" title="aggregation function"></a>aggregation function</h4><p>收集所有邻居的info，可以用sum、mean等。</p><p>$$h^{(l)}_v &#x3D; AGG^{(l)}({m^{(l)}_u, u \in N(v)})$$</p><p>$$AGG: Sum(·)，Mean(·)，Max(·) $$ 优势从左到右以此递减</p><h4 id="message-agregatio-issue"><a href="#message-agregatio-issue" class="headerlink" title="message agregatio issue"></a>message agregatio issue</h4><blockquote><p>上述的单一message+aggregation方法缺失了node-v自己的值</p></blockquote><p>$$h^{(l)} _v &#x3D; CONCAT(AGG({ { m^{(l)} _u, u \in N(v} }), m^{(l)} _v)$$</p><p>写成带学习权重的形式就是：</p><p>$$m^{(l)} _u &#x3D; W^{(l)}(h^{(l-1)} _ {u})$$</p><p>$$m^{(l)}_v &#x3D; B^{(l)}(h^{(l-1)} _ {v})$$</p><p>整个过程就是：</p><p>$$h^{(l)} _v &#x3D; CONCAT(AGG({ { W^{(l)}(h^{(l-1)} _ {u}), u \in N(v} }), B^{(l)}(h^{(l-1)} _ {v}))$$</p><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><p>$$h^{(l)}_v &#x3D; \sigma (W^{(l)} \sum\limits _ {u \in N(v)} \frac{h^{(l-1)}_u}{\mid N(v) \mid})$$</p><p>$$h^{(l)}_v &#x3D; \sigma (\sum\limits _ {u \in N(v)} W^{(l)} \frac{h^{(l-1)}_u}{\mid N(v) \mid})$$</p><p>变换后就是</p><p>$$h^{(l)} _v &#x3D; \sigma(Sum({ { m^{(l-1)} _ {u}, u \in N(v) } } ))$$</p><p>注意转换后的公式，把w移动进去后，把邻居的message即$h^{(l-1)}_u$乘上一个learning weight，再除以node的degree做一个平均normalize，这是message部分。然后在用一个$Sum(·)$做一个aggregation。最后包一层non-linear的layer。</p><p>GCN解决丢失自己node embedding的issue时，在图里添加了一个self-edges即loop，使得邻接矩阵添加了一个单位矩阵$I$。</p><p>如果写成矩阵计算的形式就是：</p><p>$$A’ &#x3D; A + I$$</p><p>$$\hat{A} &#x3D; D^{-\frac{1}{2}}A’D^{-\frac{1}{2}}$$</p><p>$$H^{(l)} _v &#x3D; \sigma(\hat{A} H^{(l-1)} _v W^{(l)})$$</p><h4 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h4><p>$$h^{(l)} _ v &#x3D; \sigma (\sum\limits _ {u \in N(v)} \alpha_{vu} W^{(l)} h^{(l-1)}_u)$$</p><p>这里的$\alpha_{vu}$是attention weights，也是通过学习得到的。</p><ul><li>在GCN里，$\alpha_{vu} &#x3D; \frac{1}{\mid N(v) \mid}$即对于某个node所有的邻居都是一个固定的权重，所有的邻居都是同等重要。</li></ul><h5 id="procedure"><a href="#procedure" class="headerlink" title="procedure"></a>procedure</h5><p>假设$e_{vu}$代表了node-u和node-v之间的重要性，$a(·)$是一个计算机制，喂入的是两个node的embedding吐出来的是一个importance，计算公式为：</p><p>$$e_{vu} &#x3D; a(W^{(l)}h^{(l-1)}_u, W^{(l)}h^{(l-1)}_v)$$</p><p>然后再用softmax函数做normalize，使得所有邻居的$e_{vu}$相加的和为1：</p><p>$$e_{vu} &#x3D; \frac{exp(e_{vu})}{\sum\limits_{k\in N(v)}exp(e_{vk})}$$</p><p>这里的$e_{vu}$就是最后的$\alpha_{vu}$</p><h5 id="about-a-·"><a href="#about-a-·" class="headerlink" title="about $a(·)$"></a>about $a(·)$</h5><p>是一个独立的机制，怎么做都可以，可以把两个embedding拿去concatenate起来过一个linear或者其它。不管怎么样，它都和前面的message的$W$是独立的，即train jointly。</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112134724732.png" alt="image-20231112134724732"></p><h5 id="multi-head-attention"><a href="#multi-head-attention" class="headerlink" title="multi-head attention"></a>multi-head attention</h5><p>像transformer一样，对于单个node可能会学多组$\alpha$，再对这些做一个aggregate</p><p>$$h^{(l)} _v[1] &#x3D; \sigma(\sum _{u \in N(v)} \alpha^1 _{vu}W^{(l)} h^{(l-1)} _u)$$</p><p>$$h^{(l)} _v[2] &#x3D; \sigma(\sum _{u \in N(v)} \alpha^2 _ {vu}W^{(l)} h^{(l-1)} _u)$$</p><p>$$h^{(l)} _v[3] &#x3D; \sigma(\sum _{u \in N(v)} \alpha^3 _{vu}W^{(l)} h^{(l-1)} _u)$$</p><p>$$h^{(l)} _v &#x3D; AGG(h^{(l)} _v[1], h^{(l)} _v[2], h^{(l)} _v[3])$$</p><p>最经典的图就是这张：</p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231115194115480.png" alt="image-20231115194115480" style="zoom:80%;"><h5 id="benefits-of-attention-mechanism"><a href="#benefits-of-attention-mechanism" class="headerlink" title="benefits of attention mechanism"></a>benefits of attention mechanism</h5><ul><li><p>使不同邻居具有不同重要性</p></li><li><p>计算可以并行化，效率高</p></li><li><p>参数的数量与图的大小无关</p></li><li><p>可以推广到不同的图</p></li></ul><h3 id="a-gnn-layer-in-practice"><a href="#a-gnn-layer-in-practice" class="headerlink" title="a gnn layer in practice"></a>a gnn layer in practice</h3><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112135412818.png" alt="image-20231112135412818"><h2 id="graph-augmentation-for-GNNs"><a href="#graph-augmentation-for-GNNs" class="headerlink" title="graph augmentation for GNNs"></a>graph augmentation for GNNs</h2><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><ul><li>图特征增强图形<ul><li>输入缺少特征</li></ul></li><li>图结构扩充<ul><li>图过于稀疏→消息传递效率低下</li><li>图太密集→消息传递成本太高</li><li>图太大→内存容不下</li></ul></li></ul><h3 id="feature-augmentation"><a href="#feature-augmentation" class="headerlink" title="feature augmentation"></a>feature augmentation</h3><p>只有邻接矩阵没有node feature</p><ul><li>加上人工的feature，加上constant values to nodes</li><li>给node编号并转换成one-hot vector</li></ul><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112151451055.png" alt="image-20231112151451055"></p><h3 id="structure-augmentation"><a href="#structure-augmentation" class="headerlink" title="structure augmentation"></a>structure augmentation</h3><h4 id="virtual-nodes-x2F-edges"><a href="#virtual-nodes-x2F-edges" class="headerlink" title="virtual nodes &#x2F; edges"></a>virtual nodes &#x2F; edges</h4><p>graph很稀疏时</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112151719163.png" alt="image-20231112151719163"></p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112151742529.png" alt="image-20231112151742529"></p><h4 id="neighborshood-sampling"><a href="#neighborshood-sampling" class="headerlink" title="neighborshood sampling"></a>neighborshood sampling</h4><p>graph很密集的时候</p><p>大幅度降低计算cost和memory cost</p><h2 id="data-splitting-for-graphs"><a href="#data-splitting-for-graphs" class="headerlink" title="data splitting for graphs"></a>data splitting for graphs</h2><p>graph的切法比较tricky，因为在graph里数据（邻居关系）是互相依赖的。</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112152403489.png" alt="image-20231112152403489"></p><h3 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h3><h4 id="transductive-seeting"><a href="#transductive-seeting" class="headerlink" title="transductive seeting"></a>transductive seeting</h4><p>不改变graph架构，但是train的时候只用部分node的标签，剩下的node的label用来validation&#x2F;test</p><h4 id="inductive-setting"><a href="#inductive-setting" class="headerlink" title="inductive setting"></a>inductive setting</h4><p>会把graph切成不同的部分，改变graph的结构</p><h4 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h4><ul><li><p>transductive</p><ul><li>在同一图上</li><li>通常在单图数据集上执行</li><li>只有标签被分割适用于节点&#x2F;边缘预测任务</li></ul><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112153004953.png" alt="image-20231112153004953" style="zoom: 80%;"></li><li><p>inductive</p><ul><li>通常在多图数据集上执行</li><li>节点&#x2F;边&#x2F;标签被分割</li><li>适用于节点&#x2F;边&#x2F;图任务</li></ul><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112153026622.png" alt="image-20231112153026622"></p></li></ul><h3 id="examples-1"><a href="#examples-1" class="headerlink" title="examples"></a>examples</h3><h4 id="graph-classification"><a href="#graph-classification" class="headerlink" title="graph classification"></a>graph classification</h4><p>比较适合使用inductive setting</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112153245764.png" alt="image-20231112153245764"></p><h4 id="link-prediction"><a href="#link-prediction" class="headerlink" title="link prediction"></a>link prediction</h4><p>是unsupervised或者self-supervised</p><h5 id="inductive"><a href="#inductive" class="headerlink" title="inductive"></a>inductive</h5><p>通常把某些edge隐藏起来，因此edge被分为两种：1）<strong>message edges</strong> 用于message passing 用于喂给GNN；2）<strong>supervision edges</strong> 用于最后预测，计算loss</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112153519135.png" alt="image-20231112153519135"></p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112153937969.png" alt="image-20231112153937969"></p><h5 id="transductive"><a href="#transductive" class="headerlink" title="transductive"></a>transductive</h5><p>通常把edge分为四种</p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112154148636.png" alt="image-20231112154148636"></p><p><img src="/2023/11/11/cs224w-graph-neural-network/image-20231112154232539.png" alt="image-20231112154232539"></p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul><li>node-level task<ul><li>inductive&#x2F;transductive settings</li></ul></li><li>graph-level task<ul><li>inductive settings</li></ul></li><li>edge-level task<ul><li>inductive&#x2F;transductive settings</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;图机器学习学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://elubrazione.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>message passing and node classification</title>
    <link href="https://elubrazione.github.io/2023/11/10/cs224w-message-passing-and-node-classification/"/>
    <id>https://elubrazione.github.io/2023/11/10/cs224w-message-passing-and-node-classification/</id>
    <published>2023-11-10T03:55:44.000Z</published>
    <updated>2023-11-16T08:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>图机器学习学习笔记</p><span id="more"></span><h2 id="node-classification"><a href="#node-classification" class="headerlink" title="node classification"></a>node classification</h2><h3 id="relational-classification"><a href="#relational-classification" class="headerlink" title="relational classification"></a>relational classification</h3><p>我周围比较接近的朋友们会慢慢影响我 &#x3D;&gt; 用已经labelled的node去预测unlabelled的node，给unlabelled的node设置一个groud truth的初始值，然后传播labelled的node。</p><p>$$P(Y_v &#x3D; c) &#x3D; \frac{1}{\sum\limits_{(u, v) \in E}A_{v,u}} \sum\limits_{(v,u) \in E} A_{v,u} P(Y_u &#x3D; c)$$</p><p>比如我要算现在这个node是绿色的机率，我就先计算我的邻居是绿色的平均机率</p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109144744695.png" alt="image-20231109144744695"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109144823807.png" alt="image-20231109144823807"></p><p>如果发现有的node机率已经不变了那么说明已经converged了，如果大多数node都已经收敛converged了则算法结束，但是如果<strong>没法收敛</strong>的化我们必须设置一个最大的iteration number，且没法利用自身node的feature和邻居的feature。</p><h3 id="iterative-classification"><a href="#iterative-classification" class="headerlink" title="iterative classification"></a>iterative classification</h3><p>方法：</p><ul><li>$\phi1(fv)$: 利用自身的node feature来预测node上面的label &#x3D;&gt; <strong>base classifier</strong></li><li>$\phi2(fv, zv)$:  除了自身的feature还用到了邻居node的label的summary &#x3D;&gt; <strong>relational classifier</strong></li></ul><p>算法：</p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109145721428.png" alt="image-20231109145721428"></p><p>例子</p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150146055.png" alt="image-20231109150146055"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150313730.png" alt="image-20231109150313730"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150347817.png" alt="image-20231109150347817"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150443517.png" alt="image-20231109150443517"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150529054.png" alt="image-20231109150529054"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150609497.png" alt="image-20231109150609497"></p><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109150629832.png" alt="image-20231109150629832"></p><h2 id="passing-message"><a href="#passing-message" class="headerlink" title="passing message"></a>passing message</h2><ol><li><p>消息</p><ul><li>准备将传递给其他节点的消息</li></ul></li><li><p>聚合和更新</p><ul><li>聚合即将到来的消息</li><li>使用聚合消息更新节点</li></ul></li></ol><p><img src="/2023/11/10/cs224w-message-passing-and-node-classification/image-20231109151028978.png" alt="image-20231109151028978"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图机器学习学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://elubrazione.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>node embeddings</title>
    <link href="https://elubrazione.github.io/2023/11/09/cs224w-node-embedding/"/>
    <id>https://elubrazione.github.io/2023/11/09/cs224w-node-embedding/</id>
    <published>2023-11-09T03:55:44.000Z</published>
    <updated>2023-11-16T08:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>图机器学习学习笔记</p><span id="more"></span><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109125304805.png" alt="image-20231109125304805"></p><p>用graph representation learning的方式代替人工的feature learning过程，即learn the features by itself</p><p>我们的最终目的是学习到一个efficient features，它是task-independent的。我么需要一个encode的部分，将graph的node map到一个dimension，map过去可以保留node之间的similarity</p><ul><li>类似nlp里面word的embedding完，原本比较接近的word在map之后也是比较接近的</li></ul><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109125708625.png" alt="image-20231109125708625"></p><p><strong>encode nodes &#x3D;&gt; similarity in embedding space (dot product) ≈ similarity in the original graph</strong></p><ul><li>编码器:节点 &#x3D;&gt; 嵌入(d维向量，$ENC(v) &#x3D; z_v$)</li><li>解码器:嵌入 &#x3D;&gt; 相似度评分(点积)</li><li>定义节点相似度函数：2个节点是否接近，接近程度如何?</li><li>优化 &#x3D;&gt; $similarity(u,v)≈z^{T}_{v} z_u$</li></ul><p>通过shallow encoding查表得方式，为每个节点被分配一个唯一的嵌入向量，优化embedding以最大化每个相似节点对(u, v)的$similarity(u,v)≈z^{T}_{v} z_u$。</p><p>如何定义节点相似度? 两个节点连接在一起? 他们共用邻居? 他们有相似的结构角色？&#x3D;&gt; 随机漫步</p><h2 id="random-walk-approaches-for-node-embeddings"><a href="#random-walk-approaches-for-node-embeddings" class="headerlink" title="random walk approaches for node embeddings"></a>random walk approaches for node embeddings</h2><p><strong>两个优点：</strong></p><ol><li>expressively：random walk的方法可以增大视野，可以使当前的node看到离当前比较远的nodes的信息</li><li>efficiently</li></ol><h3 id="feature-learning-as-optimization"><a href="#feature-learning-as-optimization" class="headerlink" title="feature learning as optimization"></a>feature learning as optimization</h3><h4 id="log-likelihood-objective"><a href="#log-likelihood-objective" class="headerlink" title="log-likelihood objective"></a>log-likelihood objective</h4><p>$$max \sum{log P(N_R(u) \mid z_u)}$$</p><p>对于每个node节点u，从u开始做random walk，对于其经过的邻居$N_R(u)$，他们的相似程度是比较高的，而非邻居节点他们的similarity是比较低的。</p><h4 id="loss-function"><a href="#loss-function" class="headerlink" title="loss function"></a>loss function</h4><p>$$\mathcal{L} &#x3D; \sum\limits_{u \in V}{\sum\limits _ {v \in N_R(u)} -log(P(v\mid z_u))}$$</p><p>$$P(v \mid z_u) &#x3D; \frac{exp(z^{T} _ {u}z_v)}{\sum\limits _ {n \in V} exp(z^{T} _ {u}z_n)}$$</p><p>因为要最大化邻居之间的相似度，log取负之后就是最小，最后minimize这个loss function即可。下面那个公式是softmax，转换成一个sum为1的机率分布，先去计算node u到其它每个node之间的similarity作为分母，分子是他的neighbors。</p><p>要计算每个node-u的similarity，时间复杂度是$O(\mid V^2\mid)$</p><p>为了方便计算我们将softmax的exp改写成sigmoid，且分母不再计算所有node，而是进行sample，采样的个数k&#x3D;5~20，k越大robust extant越高。</p><h4 id="stochastic-gradient-descent"><a href="#stochastic-gradient-descent" class="headerlink" title="stochastic gradient descent"></a>stochastic gradient descent</h4><p>sample、更新gradient</p><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109134149087.png" alt="image-20231109134149087"></p><h3 id="node2vec"><a href="#node2vec" class="headerlink" title="node2vec"></a>node2vec</h3><blockquote><p>deepwalk都假设走一个固定长度的length，每一步都随机选择unbiased。但这种方法not rich enough to embed nodes from same network community as well as nodes with similar structural roles，即我们希望能关心到同一个community里类似的node以及远方类似结构的community</p></blockquote><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109134553716.png" alt="image-20231109134553716"></p><p>设计一个<strong>biased</strong>的random walk，有意识地决定我们要走的方向，并关注similar network neighborhood，可以trade off between local and global views of the network.</p><p>two classic strategies to define a neighborhood $N_R(u)$ of a given node u: 1)BFS, 2)DFS</p><h4 id="biased-2nd-order"><a href="#biased-2nd-order" class="headerlink" title="biased 2nd-order"></a>biased 2nd-order</h4><p>如果我今天想走local的就采用bfs策略，我们就把p的值调小，1&#x2F;p机率就更大；但如果我们今天想去远方，我们就采用dfs策略，就把q的值调小，1&#x2F;q的概率就更大，更容易往远方走。</p><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109135046992.png" alt="image-20231109135111084"></p><h4 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h4><ol><li>Compute random walk probabilities</li><li>Simulate rrandom walks of length Istarting from each node u</li><li>Optimize the node2vec objective using stochastic gradient</li></ol><h2 id="applications-and-limitations-of-shallow-encoding"><a href="#applications-and-limitations-of-shallow-encoding" class="headerlink" title="applications and limitations of shallow encoding"></a>applications and limitations of shallow encoding</h2><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109140741409.png" alt="image-20231109140741409"></p><h3 id="limitations"><a href="#limitations" class="headerlink" title="limitations"></a>limitations</h3><ul><li>遇到很大的graph参数量会爆炸，因为每个node都会有自己的embedding而且每个embedding之间不会有shared的参数</li><li>出现一个新的graph就要重新跑一次random walk，即没法运用现在学到的node embedding &#x3D;&gt; <strong>inherently transductive</strong></li><li>node的feature没法考虑进去，即只能考虑node与node之间的connectivity</li></ul><h3 id="transductive-vs-inductive-learning"><a href="#transductive-vs-inductive-learning" class="headerlink" title="transductive vs. inductive learning"></a>transductive vs. inductive learning</h3><p><img src="/2023/11/09/cs224w-node-embedding/image-20231109141341522.png" alt="image-20231109141502527"></p><p>在transductive learning中，对于新的图，我们必须从头开始训练embedding的。然而，inductive可以将我们目前学到的embedding直接应用到新的graph上面来求得它的node embedding。</p><p>inductive learning on graphs &#x3D;&gt; deep encoder &#x3D;&gt; gragh neural network</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图机器学习学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://elubrazione.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>traditional feature-based methods</title>
    <link href="https://elubrazione.github.io/2023/11/07/cs224w-traditional-feature-based-methods/"/>
    <id>https://elubrazione.github.io/2023/11/07/cs224w-traditional-feature-based-methods/</id>
    <published>2023-11-07T03:55:44.000Z</published>
    <updated>2023-11-16T08:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>图机器学习学习笔记</p><span id="more"></span><blockquote><p>node, edge, graph-level prediction</p></blockquote><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108212104978.png" alt="image-20231108212104978" style="zoom:80%;"><p>feature design是非常重要的部分</p><h2 id="1-node-level-prediction"><a href="#1-node-level-prediction" class="headerlink" title="1) node-level prediction"></a>1) node-level prediction</h2><p>node的feature的表示方法分为importance-based和structure-based两种；</p><ul><li>importance-based 捕获图中节点的重要性，用于预测图中有影响的节点<ul><li>node degree</li><li>node centrality</li></ul></li><li>structure-based 捕获节点周围的局部邻域的拓扑属性，对于预测节点在图中扮演的特定角色非常有用<ul><li>node degree</li><li>clustering coefficient</li><li>graphlets</li></ul></li></ul><h3 id="importance-based"><a href="#importance-based" class="headerlink" title="importance-based"></a>importance-based</h3><h4 id="degree"><a href="#degree" class="headerlink" title="degree"></a>degree</h4><p>用度来衡量</p><h4 id="centrality"><a href="#centrality" class="headerlink" title="centrality"></a>centrality</h4><p>节点度仅计算该节点的邻居，而无法确认节点的重要性或标识这个节点，因此我们需要使用一个叫做中心度的指标来衡量一个节点的重要性。</p><ol><li><p><strong>engienvector centrality</strong> </p><p> 如果被重要的相邻节点$u$包围，则节点$v$是重要的，将节点$v$的中心性建模为相邻节点的中心性的递归和（因为$c_v$用$c_u$来计算，但是$c_u$也是用$c_v$计算）</p> <img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%202.png" alt="Untitled" style="zoom:80%;"></li><li><p><strong>betweenness centrality</strong> </p><p> 一个node如果坐落在很多最短路径上，说明它很重要</p> <img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%203.png" alt="Untitled" style="zoom: 67%;"></li><li><p><strong>closeness centrality</strong></p><p> 如果一个node到其它node最短路径都很近的话，说明它很重要，分母是他到别的node的最短路径之和。</p> <img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%204.png" alt="Untitled" style="zoom: 80%;"></li></ol><h3 id="structure-based"><a href="#structure-based" class="headerlink" title="structure-based"></a>structure-based</h3><h4 id="clustering-coefficient"><a href="#clustering-coefficient" class="headerlink" title="clustering coefficient"></a>clustering coefficient</h4><p>分子是它的邻居两两相连的个数，分母是邻居节点对个数</p><p>寻找三角形的个数（三角关系：我朋友的朋友之后也会是我的朋友）</p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%205.png" alt="Untitled" style="zoom: 80%;"><h4 id="graphlet"><a href="#graphlet" class="headerlink" title="graphlet"></a>graphlet</h4><blockquote><p><strong>graph isomorphism</strong></p><p>isomorphism表示具有相同数量的顶点、边和相同的边连通性（同构图、等价图）</p><p>简而言之就是扭来扭去之后其实是一样的</p></blockquote><p>Graphlets are <strong>induced, non-isomorphic subgraphs</strong> that describe the structure of node u’s network neighborhood</p><ul><li><p>induced subgraph表示取出两个node对时要把它们俩的边关系也取出来</p><p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108214442521.png" alt="image-20231108214442521"></p><p>u这个node，u-B还有u-E还有u-C的关系都属于$G_0$，a-c-u关系属于$G_1$，以此类推；所以u包含的graphlets有[0, 1, 2, 3, 5, 10, 11]</p></li></ul><img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%206.png" alt="Untitled" style="zoom:80%;"><p><strong>Graphlet Degree Vector (GDV)</strong> ：A count vector of graphlets rooted at a given node.</p><p>提供了一个节点的本地网络拓扑的度量(比节点度或聚类系数更详细)。</p><ul><li>示例如下：注意这里c的个数为0是因为必须是induced的</li></ul><p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108232056617.png" alt="image-20231108232056617"></p><h2 id="2-edge-level-prediction"><a href="#2-edge-level-prediction" class="headerlink" title="2) edge-level prediction"></a>2) edge-level prediction</h2><p>node与node之间是否存在edge? node与node之间edge的权重是多少?</p><ul><li><p>Distance-based features</p></li><li><p>Local neighborhood overlap</p></li><li><p>Global neighborhood overlap</p></li></ul><h3 id="distance-features"><a href="#distance-features" class="headerlink" title="distance features"></a>distance features</h3><h4 id="shortest-path-distance-between-two-nodes"><a href="#shortest-path-distance-between-two-nodes" class="headerlink" title="shortest-path distance between two nodes"></a>shortest-path distance between two nodes</h4><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108233745040.png" alt="image-20231108233745040" style="zoom: 67%;"><p>问题在于：会没办法区分shortest path一样的node，比如图上的BE和BH</p><h3 id="local-neighborhood-overlap"><a href="#local-neighborhood-overlap" class="headerlink" title="local neighborhood overlap"></a>local neighborhood overlap</h3><blockquote><p>缺点是视野很小</p></blockquote><h3 id="common-neighbors"><a href="#common-neighbors" class="headerlink" title="common neighbors"></a>common neighbors</h3><p>单纯计算两个node之间的共同neighbor个数，来衡量两个node之间的紧密程度</p><h4 id="Jaccard’s-coefficient"><a href="#Jaccard’s-coefficient" class="headerlink" title="Jaccard’s coefficient"></a>Jaccard’s coefficient</h4><p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108234534899.png" alt="image-20231108234534899"></p><p>相比common neighbors优势在于，可以看到占比，即common  neighbors多也有可能是因为两个node本来身边的neighbors就很多</p><h4 id="Adamic-Adar-index"><a href="#Adamic-Adar-index" class="headerlink" title="Adamic-Adar index"></a>Adamic-Adar index</h4><p>计算两个node的共同的邻居的degree取log取倒数再相加，即共同邻居的degree越大，最后得到的权重value越小</p><p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231108234606390.png" alt="image-20231108234630499"></p><h3 id="global-neighborhood-overlap"><a href="#global-neighborhood-overlap" class="headerlink" title="global neighborhood overlap"></a>global neighborhood overlap</h3><p>希望能看到更大的视野</p><h4 id="Katz-index"><a href="#Katz-index" class="headerlink" title="Katz index"></a>Katz index</h4><p>先计算点对之间所有长度路径的条数，一般的方法是先用邻接矩阵的幂次方来计算，k次方就代表了节点对之间长度位k的路径的条数，最后根据length的长度从1到无穷每个乘上一个系数并加起来。</p><p>衡量一个node是否处在一个比较发达&#x2F;偏僻的地方。</p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%207.png" alt="Untitled" style="zoom: 50%;"><h2 id="3-graph-level-prediction"><a href="#3-graph-level-prediction" class="headerlink" title="3) graph-level prediction"></a>3) graph-level prediction</h2><p>前两次是如何去较好地表示node和edge的feature的表达方式</p><p>图级别特征构建目标：找到能够描述全图结构的特征，让比较相似的两个graph定义得到的feature的similarity是比较高的。</p><p>找到一个函数$\phi$，把graph表示为一个vector的representation，最后两个graph的similarity可以由两个$\phi$函数的内积计算得到.</p><p>所以我们的目标是设计一个bgraph kernel $\phi(G)$</p><ul><li><p>bag-of-Words </p><ul><li><p>在NLP中，BoW将单词在文档中的频率作为特征来计算。</p></li><li><p>最简单的方法：将节点视为单词</p></li><li><p>下图中这样设计出来的$\phi$的结果都是4，这两个graph是相同的</p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231109121253428.png" alt="image-20231109121253428" style="zoom: 67%;"></li></ul></li><li><p>bag-of-degrees</p></li></ul><img src="/2023/11/07/cs224w-traditional-feature-based-methods/Untitled%208.png" alt="Untitled" style="zoom: 67%;"><h3 id="graphlet-features"><a href="#graphlet-features" class="headerlink" title="graphlet features"></a>graphlet features</h3><p>在这里看graphlet是基于整个graphlet的视野</p><p><img src="/2023/11/07/cs224w-traditional-feature-based-methods/image-20231109123607394.png" alt="image-20231109123607394"></p><p>得到$f(G)$后对其作一个normalization</p><p>但是存在的问题是graphlet的计算十分复杂</p><h3 id="weisfeiler-lehman-kernel"><a href="#weisfeiler-lehman-kernel" class="headerlink" title="weisfeiler-lehman kernel"></a>weisfeiler-lehman kernel</h3><ul><li>bag of colors</li><li>capture graph structure within k-hop</li><li>computationally efficient</li><li>closely related to graph neural network</li></ul><p>$$c^{(k+1)}(v) &#x3D; HASH({ c^{(k)}(v), {c^{(k)}(u)}_{u \in N(v)} })$$</p><p>aggregate邻居的颜色，然后根据当前串hash table转到不同的color，相当于把邻居的颜色concat到自己的颜色后面。</p><p>color refinement结束之后，WL kernel计算每个颜色出现过的次数，用$\phi$转换成feature vector，最后将两个$\phi(G)$内积相乘，得到的结果越高说明similarity越高即颜色相同的node越多</p><p>这样的优点是它的开销相比graphlet的方式低了非常多。</p><p>color refinement也可以用来检测两个graph是否是isomorphism的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图机器学习学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://elubrazione.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://elubrazione.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GNN" scheme="https://elubrazione.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>Tsunami：a learned multi-dimensional index for correlated data and skewed workloads</title>
    <link href="https://elubrazione.github.io/2023/09/13/idsm-tsunami-indexes/"/>
    <id>https://elubrazione.github.io/2023/09/13/idsm-tsunami-indexes/</id>
    <published>2023-09-13T13:58:28.000Z</published>
    <updated>2023-09-17T13:59:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>VLDB2020</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;VLDB2020&lt;/p&gt;</summary>
    
    
    
    <category term="腾讯AI训练营" scheme="https://elubrazione.github.io/categories/%E8%85%BE%E8%AE%AFAI%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="多维索引" scheme="https://elubrazione.github.io/tags/%E5%A4%9A%E7%BB%B4%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级2023夏真题</title>
    <link href="https://elubrazione.github.io/2023/09/11/pat-2023-summer/"/>
    <id>https://elubrazione.github.io/2023/09/11/pat-2023-summer/</id>
    <published>2023-09-11T11:38:03.000Z</published>
    <updated>2023-11-25T14:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT考试真题解析</p><span id="more"></span><h1 id="A-1-Trap-20"><a href="#A-1-Trap-20" class="headerlink" title="[A-1] Trap (20)"></a>[A-1] Trap (20)</h1><blockquote><p>DFS</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A robot is designed to move on a map from South toward North. When some obstacle is encountered, the robot can only turn toward West and moves until it can turn toward North and continue.</p><p>Given a squared map with $n×n$ blocks, a robot can start from any position below the bottom line (South) and its target is to reach the top line (North). (By the way, kindly remind you that the left-hand-side of the map is West and the right-hand-side is East.)</p><p>If some obstacles are placed in the map, the robot might get trapped if it starts from certain positions and can never reach the North line. For example, in the situation given by the following figure, the robot will be trapped if it starts from either position 7 or 8.</p><p><img src="/2023/09/11/pat-2023-summer/1.jpg" alt="a1"></p><p>Your job is to point out those starting positions which will get the robot trapped.</p><p><strong>Note</strong>: it is assumed that a robot can move <strong>out of the map boundary</strong>, and all the blocks around the map are open, without any obstacle. Hence if the robot starts from any position out of the West or East boundary, it can certainly reach North without any problem. Therefore we only have to consider the positions between the West and East boundaries (e.g. the positions from 1 to 10 below the South line in the above figure). Besides, as long as the robot can reach the North line, it is considered successful even of it ends up at out of the boundary (e.g. the robot will have to move out of the map if starts from either the positions 1 or 2, but it can still reach the North line).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts from a positive integer $n (≤100)$ in a line, which is the size of the map. Then n lines follow, each contains n characters, which are either <code>0</code> for an open block, or <code>1</code> for a block with obstacle. The first line corresponds to the North boundary and the last line the South.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Output in a line all the starting positions which can get the robot trapped, in increasing order. The positions are indexed from West to East, starting from 1. It is guaranteed that there is at least one output.<br>All the numbers must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">0000000000</span><br><span class="line">0000111010</span><br><span class="line">1100100011</span><br><span class="line">0000110001</span><br><span class="line">0000000011</span><br><span class="line">0000000000</span><br><span class="line">0100000100</span><br><span class="line">0001000000</span><br><span class="line">0001000000</span><br><span class="line">0001100000</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br></pre></td></tr></table></figure><h2 id="注意点与解析"><a href="#注意点与解析" class="headerlink" title="注意点与解析"></a>注意点与解析</h2><ul><li>这题可惜得我真的想四。题目的意思是从第n+1行出发，能往北走往北走，不能往北走就往西走，<strong>直到能往北走为止</strong>。而不是不能往北走后一直往西走。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (num[i<span class="number">-1</span>][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, j);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (num[i][j<span class="number">-1</span>] == <span class="number">0</span>)  <span class="keyword">return</span> <span class="built_in">dfs</span>(i, j - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  num.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;num[i][j]);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">dfs</span>(n, i);</span><br><span class="line">    <span class="keyword">if</span> (!flag)  ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">if</span> (i != ans.<span class="built_in">size</span>() - <span class="number">1</span>)  cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-2-Queue-Using-Two-Stacks-25"><a href="#A-2-Queue-Using-Two-Stacks-25" class="headerlink" title="[A-2] Queue Using Two Stacks (25)"></a>[A-2] Queue Using Two Stacks (25)</h1><blockquote><p>栈</p></blockquote><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:</p><ol><li>Start from two empty stacks $s_1$ and $s_2$.</li><li>When element $e$ is enqueued, it is actually pushed onto $s_1$.</li><li>When we are supposed to dequeue, $s_2$ is checked first. If $s_2$ is empty everything in $s_1$ will be transferred to $s_2$ by popping from $s_1$ and immediately pushing onto $s_2$. Then we just pop from $s_2$ – the top element of $s_2$ must be the first one to enter $s_1$ thus is the first element that was enqueued.</li></ol><p>Assume that each operation of push or pop takes 1 unit of time. You job is to tell the time taken for each dequeue.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer $N (≤10^3)$, which are the number of operations. Then $N$ lines follow, each gives an operation in the format</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operation Element</span><br></pre></td></tr></table></figure><p>where <code>Operation</code> being <code>I</code> represents enqueue and <code>O</code> represents dequeue. For each <code>I</code>, <code>Element</code> is a positive integer that is no more than $10^6$. No <code>Element</code> is given for <code>O</code> operations.<br>It is guaranteed that there is at least one <code>O</code> operation.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each dequeue operation, print in a line the dequeued element and the unites of time taken to do this dequeue. The numbers in a line must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.<br>In case that the queue is empty when dequeue is called, output in a line <code>ERROR</code> instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">I 20</span><br><span class="line">I 32</span><br><span class="line">O</span><br><span class="line">I 11</span><br><span class="line">O</span><br><span class="line">O</span><br><span class="line">O</span><br><span class="line">I 100</span><br><span class="line">I 66</span><br><span class="line">O</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">20 5</span><br><span class="line">32 1</span><br><span class="line">11 3</span><br><span class="line">ERROR</span><br><span class="line">100 5</span><br></pre></td></tr></table></figure><h2 id="注意点与解析-1"><a href="#注意点与解析-1" class="headerlink" title="注意点与解析"></a>注意点与解析</h2><ul><li>没什么好说的，模拟就完事</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="type">int</span> n, ele;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;I&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; ele;</span><br><span class="line">      s<span class="number">1.</span><span class="built_in">push</span>(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="type">int</span> temp = s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">          s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">          s<span class="number">2.</span><span class="built_in">push</span>(temp);</span><br><span class="line">          ans += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR\n&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> temp = s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, temp, ans);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-3-Rank-of-Binary-Tree-25"><a href="#A-3-Rank-of-Binary-Tree-25" class="headerlink" title="[A-3] Rank of Binary Tree (25)"></a>[A-3] Rank of Binary Tree (25)</h1><blockquote><p>树的遍历</p></blockquote><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>Here we define the <strong>rank</strong> of a binary tree as $n_1×n_2&#x2F;n_0$ where $n_i$ is the number of nodes of degree $i$ for $i&#x3D;0,1,2$.<br>For example, given a tree shown by the figure, its rank is $2×3&#x2F;4&#x3D;1.5$.</p><p><img src="/2023/09/11/pat-2023-summer/2.jpg" alt="a1"></p><p>Given the inorder and preorder traversal sequences of a binary tree, you are supposed to calculate its rank.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer $N (≤20)$, which is the total number of nodes in the tree. Then given in the following 2 lines are the inorder and preorder traversal sequences of the tree, respectively. All the keys in the tree are distinct positive integers in the range of <strong>int</strong>.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in a line the way we calculate the rank, and the <strong>integer part</strong> of the rank. The format is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 * n2 / n0 = rank</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">2 3 1 5 4 7 8 6 9</span><br><span class="line">1 2 3 6 7 4 5 8 9</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 * 3 / 4 = 1</span><br></pre></td></tr></table></figure><h2 id="注意点与解析-2"><a href="#注意点与解析-2" class="headerlink" title="注意点与解析"></a>注意点与解析</h2><ul><li>老朋友了</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pre, in, <span class="built_in">ans</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(<span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL, <span class="type">int</span> inR)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (preL &gt; preR)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">  root -&gt; val = pre[preL];</span><br><span class="line">  root -&gt; left = root -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> k = inL;</span><br><span class="line">  <span class="keyword">while</span> (k != inR &amp;&amp; in[k] != pre[preL])  k++;</span><br><span class="line">  <span class="type">int</span> numLeft = k - inL;</span><br><span class="line">  root -&gt; left = <span class="built_in">insert</span>(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>);</span><br><span class="line">  root -&gt; right = <span class="built_in">insert</span>(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (root -&gt; left &amp;&amp; root -&gt; right)  ans[<span class="number">2</span>]++;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (root -&gt; left || root -&gt; right) ans[<span class="number">1</span>]++;</span><br><span class="line">  <span class="keyword">else</span>  ans[<span class="number">0</span>]++;</span><br><span class="line">  <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">  <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  pre.<span class="built_in">resize</span>(n);</span><br><span class="line">  in.<span class="built_in">resize</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; in[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; pre[i];</span><br><span class="line">  TreeNode *root = <span class="built_in">insert</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(root);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d * %d / %d = %d&quot;</span>, ans[<span class="number">1</span>], ans[<span class="number">2</span>], ans[<span class="number">0</span>], ans[<span class="number">1</span>]*ans[<span class="number">2</span>]/ans[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-4-Big-Number-30"><a href="#A-4-Big-Number-30" class="headerlink" title="[A-4] Big Number (30)"></a>[A-4] Big Number (30)</h1><blockquote><p>DFS，贪心</p></blockquote><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>How to generate a big number of $N$ digits randomly? One way is to find $N$ kids, give each one a card with one’s index written on one side (hence it is assumed that the kids are indexed from 1 to $N$), and ask them to write down a 1-digit number randomly on the other side. Then let the kids pin their digits in a line, on the wall, one by one in ascending order of their indices.</p><p>However, it’s very difficult to let hundreds of thousands of kids to follow the order. The result is that we have cards pinned randomly all over the wall, some even show the wrong sides. For example, if the 23rd kid has written down 8, we are supposed to find the number 8 on the wall. But instead we might find 23… Your job is to rearrange these cards so that we can obtain the big number as required.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer $N (≤10^5)$. Then N lines follow, each describes a card in the format <code>n1 n2</code> where the two numbers are the numbers written on the two sides of a card.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line the N-digit number as required. That is, print the digits written by the kids in ascending order of their indices. In case that there are 1-digit numbers written on both sides, it would be hard to tell which one is the index and which one is the number written by the kid. Hence the solution may not be unique. In this case, just output the smallest resulting number.</p><p>It is guaranteed that a solution exists.</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">7 11</span><br><span class="line">8 9</span><br><span class="line">3 1</span><br><span class="line">2 12</span><br><span class="line">4 6</span><br><span class="line">10 0</span><br><span class="line">5 1</span><br><span class="line">2 5</span><br><span class="line">6 8</span><br><span class="line">1 4</span><br><span class="line">7 2</span><br><span class="line">9 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">359114268072</span><br></pre></td></tr></table></figure><h2 id="注意点与解析-3"><a href="#注意点与解析-3" class="headerlink" title="注意点与解析"></a>注意点与解析</h2><ul><li>对于一组数，只要出现2位以上的数，它就必定表示这一组数的数位，那么另一个数就是这一位的数值。因此，出现不同情况的只可能是下标为1到9的9组数。</li><li>数据规模很小，所以算法的时间复杂度可以很奢侈。使用贪心，对每组的两个数哪个是下标哪个是数值，既然不知道，那就都试试。建立数组tv存这9组数，借助dfs从1到9逐渐完善tv。每试完一组，用集合cap来记住这一组的信息已经用掉了，把它erase掉，用完的信息存入tv，进入下一层dfs。</li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; tv, vector&lt;<span class="type">int</span>&gt;&amp; res, set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&amp; cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="number">10</span> || cur &gt; n) &#123;</span><br><span class="line">    res = <span class="built_in">min</span>(res, tv);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur==<span class="number">1</span>&amp;&amp;i==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (cap.<span class="built_in">count</span>(&#123;cur, i&#125;)) &#123;</span><br><span class="line">      cap.<span class="built_in">erase</span>(&#123;cur, i&#125;);</span><br><span class="line">      tv[cur] = i;</span><br><span class="line">      <span class="built_in">dfs</span>(cur<span class="number">+1</span>, tv, res, cap);</span><br><span class="line">      cap.<span class="built_in">emplace</span>(cur, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cap.<span class="built_in">count</span>(&#123;i, cur&#125;)) &#123;</span><br><span class="line">      cap.<span class="built_in">erase</span>(&#123;i, cur&#125;);</span><br><span class="line">      tv[cur] = i;</span><br><span class="line">      <span class="built_in">dfs</span>(cur<span class="number">+1</span>, tv, res, cap);</span><br><span class="line">      cap.<span class="built_in">emplace</span>(i, cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; cap;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//storage: index &gt;= 10</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      v[a] = b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      v[b] = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cap.<span class="built_in">count</span>(&#123;a, b&#125;)) cap.<span class="built_in">emplace</span>(b, a);</span><br><span class="line">      <span class="keyword">else</span> cap.<span class="built_in">emplace</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">10</span>, <span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tv</span><span class="params">(<span class="number">10</span>, <span class="number">0x3f3f3f3f</span>)</span></span>;<span class="comment">//temp vector</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, tv, res, cap);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> &amp;&amp; i &lt;= n; ++i) &#123;</span><br><span class="line">    cout&lt;&lt;res[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &lt;= n; ++i) cout&lt;&lt;v[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;PAT考试真题解析&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://elubrazione.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树的遍历" scheme="https://elubrazione.github.io/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
    <category term="贪心" scheme="https://elubrazione.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="DFS" scheme="https://elubrazione.github.io/tags/DFS/"/>
    
    <category term="栈" scheme="https://elubrazione.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
